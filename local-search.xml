<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端面试 16-面试技巧 by smyhvae</title>
    <link href="/blog/20200321/"/>
    <url>/blog/20200321/</url>
    
    <content type="html"><![CDATA[<h2 id="写简历的注意事项"><a href="#写简历的注意事项" class="headerlink" title="写简历的注意事项"></a>写简历的注意事项</h2><ul><li>最多可以写“深入了解”，但不要写“精通”。</li></ul><h2 id="遇到不知道的问题，该怎么回答"><a href="#遇到不知道的问题，该怎么回答" class="headerlink" title="遇到不知道的问题，该怎么回答"></a>遇到不知道的问题，该怎么回答</h2><ul><li><p>这块儿我没了解过，准备回去看一下。</p></li><li><p>这块儿我没研究过，您有没有好的资料，我可以补充一下细节。</p></li><li><p>写不出详细的代码，但是知道思路。</p></li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ul><li>面试要体现项目的设计思路、方案设计等</li></ul><h2 id="模块化思维"><a href="#模块化思维" class="headerlink" title="模块化思维"></a>模块化思维</h2><p>（1）模块化设计的关键词：<strong>封装、继承</strong>；把<strong>通用</strong>的模块<strong>先抽象，后具体</strong>，达到<strong>复用</strong>。【面试记住】</p><p>比如，<strong>panel、按钮、轮播图</strong>、列表等等，都可以提取为<strong>抽象</strong>的组件，复用。</p><p>（2）页面有哪几个模块</p><p>（3）每个模块分成不同的文件，然后在index页面中import。</p><h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><ul><li><p>let、const</p></li><li><p>函数扩展：参数默认值、箭头函数、扩展运算符<code>...</code></p></li><li><p>for … of 循环</p></li><li><p>map</p></li><li><p>模块化</p></li></ul><h2 id="薪资"><a href="#薪资" class="headerlink" title="薪资"></a>薪资</h2><p>面试官；”你要求多少薪资？”</p><p>我：“能给个范围吗？”</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 15-网友面经</title>
    <link href="/blog/20200320/"/>
    <url>/blog/20200320/</url>
    
    <content type="html"><![CDATA[<h3 id="2018-03-08"><a href="#2018-03-08" class="headerlink" title="2018-03-08"></a>2018-03-08</h3><ul><li><a href="https://github.com/jawil/blog/issues/22" target="_blank" rel="noopener">jawil | 一年经验初探阿里巴巴前端社招</a></li></ul><p>此博主的博客签名：</p><p>20180308_1703.png</p><ul><li><a href="https://blog.dunizb.com//2017/09/08/interview-questions-2017/" target="_blank" rel="noopener">2017我遇到的前端面试题</a></li></ul><p>作者整理的这些题目，很多是来自面试跳槽的视频。非常推荐。</p><p>作者说，性能优化和ES6，是必问的。</p><ul><li><a href="https://www.cnblogs.com/wdlhao/p/8290436.html" target="_blank" rel="noopener">2018年web前端经典面试题及答案</a></li></ul><p>写得很长啊。</p><h3 id="2018-03-11"><a href="#2018-03-11" class="headerlink" title="2018-03-11"></a>2018-03-11</h3><ul><li><p><a href="http://www.bijishequ.com/detail/421600?p=" target="_blank" rel="noopener">2017年BAT面试题大全集</a></p></li><li><p><a href="https://www.jianshu.com/p/d94d5290328c" target="_blank" rel="noopener">bat前端面试内容记录</a></p></li></ul><h3 id="2018-03-18"><a href="#2018-03-18" class="headerlink" title="2018-03-18"></a>2018-03-18</h3><ul><li><p><a href="https://zhoukekestar.github.io/notes/2017/06/07/interview-answers.html" target="_blank" rel="noopener">笔记：阿里、网易、滴滴共十次前端面试碰到的问题</a></p></li><li><p><a href="https://zhoukekestar.github.io/notes/2017/07/06/interview-answers.html" target="_blank" rel="noopener">笔记补充：阿里、网易、滴滴共十次前端面试碰到的问题</a></p></li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 14-面试题整理 by smyhvae</title>
    <link href="/blog/20200319/"/>
    <url>/blog/20200319/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="存储相关：请描述以下cookie、localStorage、sessionStorage的区别"><a href="#存储相关：请描述以下cookie、localStorage、sessionStorage的区别" class="headerlink" title="存储相关：请描述以下cookie、localStorage、sessionStorage的区别"></a>存储相关：请描述以下cookie、localStorage、sessionStorage的区别</h3><blockquote><p>在H5之前，cookie一直都是本地存储的一个重要的方法。直到后面的两个出现了， 就开始用后面的两个做本地存储。</p></blockquote><p><strong>1、cookie</strong>：</p><ul><li><p>本身用于客户端和服务器端的通信。</p></li><li><p>但是它有本地存储的功能，于是就被“借用”。</p></li></ul><p>我们可以通过<code>document.cookie</code>获取和修改cookie，获取到的其实就是一个字符串。</p><p>cookie用于存储时的缺点：</p><ul><li><p>存储量太小，只有4kb</p></li><li><p>所有http请求都带着，会影响获取资源的效率</p></li><li><p>api简单，需要封装才能用。<code>document.cookie = ...</code></p></li></ul><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="HTML5新增了哪些内容或API？使用过哪些？"><a href="#HTML5新增了哪些内容或API？使用过哪些？" class="headerlink" title="HTML5新增了哪些内容或API？使用过哪些？"></a>HTML5新增了哪些内容或API？使用过哪些？</h3><p>新元素：</p><ul><li><code>&lt;section&gt;</code>、<code>&lt;footer&gt;</code> 和 <code>&lt;header&gt;</code>等</li></ul><p>新的api：</p><ul><li>网络存储: sessionStorage 和 localStorage</li></ul><p>参考链接：</p><ul><li><a href="https://zhoukekestar.github.io/notes/2017/06/07/interview-answers.html" target="_blank" rel="noopener">笔记：阿里、网易、滴滴共十次前端面试碰到的问题</a></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="如何让一个div元素隐藏？你能想到的方式有几种？"><a href="#如何让一个div元素隐藏？你能想到的方式有几种？" class="headerlink" title="如何让一个div元素隐藏？你能想到的方式有几种？"></a>如何让一个div元素隐藏？你能想到的方式有几种？</h3><p>-</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="for-each、for-in、for-of的区别"><a href="#for-each、for-in、for-of的区别" class="headerlink" title="for each、for in、for of的区别"></a>for each、for in、for of的区别</h3><ul><li><p><code>foreach</code>用于遍历数组，是数组的一个方法。不支持 return。</p></li><li><p><code>for ... in</code>获取的对象是index索引值。</p></li><li><p><code>for ... of</code>获取的是对象里的值。</p></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="浏览器输入url到显示内容，有哪些过程"><a href="#浏览器输入url到显示内容，有哪些过程" class="headerlink" title="浏览器输入url到显示内容，有哪些过程"></a>浏览器输入url到显示内容，有哪些过程</h3><p>（1）浏览器解析url。包括：协议、域名、端口号、资源路径、参数查询</p><p>（2）DNS解析</p><p>（3）TCP握手</p><p>（4）HTTP请求</p><p>（5）服务器处理请求</p><p>（6）浏览器渲染：DOM tree、CSS rule tree、render tree。</p><p>（7）display</p><p>参考链接：</p><ul><li><p><a href="https://zhoukekestar.github.io/notes/2017/06/07/interview-answers.html" target="_blank" rel="noopener">笔记：阿里、网易、滴滴共十次前端面试碰到的问题</a></p></li><li><p><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></p></li></ul><ul><li><p><a href="https://mp.weixin.qq.com/s/3_DZKSP492uq9RfQ3eW4_A" target="_blank" rel="noopener">码农翻身 | 小白科普：从输入网址到最后浏览器呈现页面内容，中间发生了什么？</a></p></li><li><p>从输入URL到页面加载发生了什么：<a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></p></li></ul><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ul><li>[荐]面试题和答案：<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers</a></li></ul><ul><li>面试题和答案：<a href="https://github.com/qiu-deqing/FE-interview" target="_blank" rel="noopener">https://github.com/qiu-deqing/FE-interview</a></li></ul><p>有个题是，浏览器输入url，有哪些过程</p><ul><li><p><a href="https://github.com/WarpPrism/Blog/issues/5" target="_blank" rel="noopener">讲到了Cookie和session</a></p></li><li><p>这个也很全：<a href="https://github.com/gnipbao/Front-end-Interview-questions" target="_blank" rel="noopener">https://github.com/gnipbao/Front-end-Interview-questions</a></p></li><li><p><a href="https://github.com/giscafer/front-end-manual/issues/3" target="_blank" rel="noopener">https://github.com/giscafer/front-end-manual/issues/3</a></p></li></ul><h2 id="按时间排列"><a href="#按时间排列" class="headerlink" title="按时间排列"></a>按时间排列</h2><h3 id="2018-03-11"><a href="#2018-03-11" class="headerlink" title="2018-03-11"></a>2018-03-11</h3><ul><li><p>web前端面试题汇总：<a href="https://www.jianshu.com/p/2f7eb1ad7174" target="_blank" rel="noopener">https://www.jianshu.com/p/2f7eb1ad7174</a></p></li><li><p>2017前端面试题及答案总结：<a href="https://yeaseonzhang.github.io/2017/09/17/2017%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://yeaseonzhang.github.io/2017/09/17/2017%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%80%BB%E7%BB%93/</a></p></li></ul><h3 id="2018-03-12-今日头条面试题"><a href="#2018-03-12-今日头条面试题" class="headerlink" title="2018-03-12-今日头条面试题"></a>2018-03-12-今日头条面试题</h3><ul><li><a href="http://blog.csdn.net/github_35924246/article/details/75675901" target="_blank" rel="noopener">今日头条一面笔试面试题！！！！！完整</a></li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 13-MVVM</title>
    <link href="/blog/20200318/"/>
    <url>/blog/20200318/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MVVM的常见问题：</p><ul><li><p>如何理解MVVM</p></li><li><p>如何实现MVVM</p></li><li><p>是否解读过Vue的源码</p></li></ul><p>题目：</p><ul><li>说一下使用 jQuery 和使用框架的区别</li></ul><ul><li>说一下对 MVVM 的理解</li></ul><ul><li>vue 中如何实现响应式</li></ul><ul><li><p>vue 中如何解析模板</p></li><li><p>vue 的整个实现流程</p></li></ul><h2 id="说一下使用-jQuery-和使用框架的区别"><a href="#说一下使用-jQuery-和使用框架的区别" class="headerlink" title="说一下使用 jQuery 和使用框架的区别"></a>说一下使用 jQuery 和使用框架的区别</h2><h2 id="MVVM-Vue"><a href="#MVVM-Vue" class="headerlink" title="MVVM / Vue"></a>MVVM / Vue</h2><h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><ul><li><p>Model：负责数据存储</p></li><li><p>View：负责页面展示</p></li><li><p>View Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示</p></li></ul><p>数据驱动视图，只关心数据变化，DOM操作被封装。</p><h3 id="MVVM-Vue的三要素"><a href="#MVVM-Vue的三要素" class="headerlink" title="MVVM / Vue的三要素"></a>MVVM / Vue的三要素</h3><ul><li><p><strong>响应式</strong>：vue 如何监听到 data 的每个属性变化？</p></li><li><p><strong>模板引擎</strong>：vue 的模板如何被解析，指令如何处理？</p></li></ul><ul><li><strong>渲染</strong>：vue 的模板如何被渲染成 html ？以及渲染过程</li></ul><h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3><p>传统的web开发，是利用 jQuery操作DOM，这是非常耗资源的。</p><p>我们可以在 JS 的内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析，一次性插入到html里去。这就形成了虚拟 DOM。</p><p>Vue1.0没有虚拟DOM，Vue2.0改成了基于虚拟DOM。</p><h3 id="如何理解MVC"><a href="#如何理解MVC" class="headerlink" title="如何理解MVC"></a>如何理解MVC</h3><p>C指的是Controller。控制器能够控制视图的变化，也能控制数据的变化。</p><p>单项通信。一般情况下是：view 发出命令给控制器，控制器处理业务逻辑后控制 Model，Model再去改 view。</p><h2 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>不是所有的场景都适合用 hybrid：</p><ul><li><p>使用原生应用：体验要求极致，变化不频繁（如头条的首页）</p></li><li><p>使用 hybrid：体验要求高，变化频繁（如新闻详情页）</p></li><li><p>使用H5：体验无要求、不常用（比举报、反馈等）</p></li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 12-虚拟DOM</title>
    <link href="/blog/20200317/"/>
    <url>/blog/20200317/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vdom 是 vue 和 React 的<strong>核心</strong>，先讲哪个都绕不开它。</p><p>vdom 比较独立，使用也比较简单。</p><p>如果面试问到 vue 和 React 和实现，免不了问 vdom：</p><ul><li><p>vdom 是什么？为何会存在 vdom？</p></li><li><p>vdom 的如何应用，核心 API 是什么</p></li><li><p>介绍一下 diff 算法</p></li></ul><h2 id="什么是-vdom"><a href="#什么是-vdom" class="headerlink" title="什么是 vdom"></a>什么是 vdom</h2><h3 id="什么是-vdom-1"><a href="#什么是-vdom-1" class="headerlink" title="什么是 vdom"></a>什么是 vdom</h3><p>DOM操作是昂贵的。</p><p>步骤一：用JS对象模拟DOM树</p><p>步骤二：比较两棵虚拟DOM树的差异</p><p>步骤三：把差异应用到真正的DOM树上</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 11-01.ES6：模块化的使用和编译环境</title>
    <link href="/blog/20200316/"/>
    <url>/blog/20200316/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="ES6的主要内容"><a href="#ES6的主要内容" class="headerlink" title="ES6的主要内容"></a>ES6的主要内容</h3><ul><li><p>模块化的使用和编译环境</p></li><li><p>Class与JS构造函数的区别</p></li><li><p>Promise的用法</p></li><li><p>ES6其他常用功能</p></li></ul><p>本文来讲“模块化的使用和编译环境”。</p><h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><ul><li><p>ES6 模块化如何使用，开发环境如何打包</p></li><li><p>Class 和普通构造函数有何区别</p></li><li><p>Promise 的基本使用和原理</p></li><li><p>总结一下 ES6 其他常用功能</p></li></ul><h3 id="ES6的现状"><a href="#ES6的现状" class="headerlink" title="ES6的现状"></a>ES6的现状</h3><ul><li><p>开发环境已经普及使用</p></li><li><p>浏览器环境却支持不好（需要开发环境编译）</p></li><li><p>内容很多，重点了解常用语法</p></li><li><p>面试：开发环境的使用 + 重点语法的掌握</p></li></ul><h2 id="模块化的基本语法"><a href="#模块化的基本语法" class="headerlink" title="模块化的基本语法"></a>模块化的基本语法</h2><p>（1）util1.js：</p><pre><code class="javascript">export default var a = 100;export function foo {  console.log(&#39;util1-foo&#39;);}</code></pre><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出。</p><p>有了默认输出之后，其他模块加载该模块时，import命令可以为该匿名变量/函数，起<strong>任意的名字</strong>。</p><p>上面的代码中，默认输出是一个变量。当然，我们也可以换成<strong>默认输出一个匿名函数</strong>：</p><pre><code class="javascript">export default function() {  console.log(&#39;util1-function&#39;);}</code></pre><p>（2）util2.js：</p><pre><code class="javascript">export var myUtil2 = &#39;this is util2&#39;;export function fn1() {  console.log(&#39;util2-fn1&#39;);}export function fn2() {  console.log(&#39;util2-fn2&#39;);}</code></pre><p>上方代码中，我把一个变量和两个函数作为了导出。</p><p>（3）index.js：</p><h2 id="Class和普通构造函数有何区别"><a href="#Class和普通构造函数有何区别" class="headerlink" title="Class和普通构造函数有何区别"></a>Class和普通构造函数有何区别</h2><blockquote><p>我们经常会用ES6中的Class来代替JS中的构造函数做开发。</p></blockquote><ul><li><p>Class 在语法上更加贴合面向对象的写法</p></li><li><p>Class 实现继承更加易读、易理解</p></li></ul><ul><li>更易于写 java 等后端语言的使用</li></ul><ul><li>本质还是语法糖，使用 prototype</li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 11-00.JavaScript高级面试：前言</title>
    <link href="/blog/20200315/"/>
    <url>/blog/20200315/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一、基础知识：</p><ul><li><p>ES 6常用语法：class 、module、Promise等</p></li><li><p>原型高级应用：结合 jQuery 和 zepto 源码</p></li><li><p>异步全面讲解：从原理到 jQuery 再到 Promise</p></li></ul><p>二、框架原理：</p><ul><li><p>虚拟DOM：存在价值、如何使用、diff算法</p></li><li><p>MVVM vue：MVVM、vue响应式、模板解析、渲染</p></li><li><p>组件化 React：组件化、JSX、vdom、setState</p></li></ul><p>三、混合开发：</p><ul><li><p>hybrid</p></li><li><p>H5</p></li><li><p>前端客户端通讯</p></li></ul><p>内容优势</p><ul><li><p>面试官爱问“源码”、“实现”。</p></li><li><p>介绍常用框架实现原理</p></li><li><p>介绍hybrid原理和应用</p></li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li><p>模块化的使用和编译环境</p></li><li><p>Class与JS构造函数的区别</p></li><li><p>Promise的用法</p></li><li><p>ES6其他常用功能</p></li></ul><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul><li>什么是单线程，和异步有什么关系</li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 10-02.前端错误监控</title>
    <link href="/blog/20200314/"/>
    <url>/blog/20200314/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>错误监控包含的内容是：</p><ul><li><p>前端错误的分类</p></li><li><p>每种错误的捕获方式</p></li><li><p>上报错误的基本原理</p></li></ul><p>面试时，可能有两种问法：</p><ul><li><p>如何监测 js 错误？（开门见山的方式）</p></li><li><p>如何保证<strong>产品质量</strong>？（其实问的也是错误监控）</p></li></ul><h2 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h2><p>包括两种：</p><ul><li><p>即时运行错误（代码错误）</p></li><li><p>资源加载错误</p></li></ul><h2 id="每种错误的捕获方式"><a href="#每种错误的捕获方式" class="headerlink" title="每种错误的捕获方式"></a>每种错误的捕获方式</h2><h3 id="即时运行错误的捕获方式"><a href="#即时运行错误的捕获方式" class="headerlink" title="即时运行错误的捕获方式"></a>即时运行错误的捕获方式</h3><p><strong>方式1</strong>：try … catch。</p><p>这种方式要部署在代码中。</p><p><strong>方式2：</strong><code>window.onerror</code>函数。这个函数是全局的。</p><pre><code>    window.onerror = function(msg, url, row, col, error) { ... }</code></pre><p>参数解释：</p><ul><li><p>msg为异常基本信息</p></li><li><p>source为发生异常Javascript文件的url</p></li><li><p>row为发生错误的行号</p></li></ul><p>方式二中的<code>window.onerror</code>是属于DOM0的写法，我们也可以用DOM2的写法：<code>window.addEventListener(&quot;error&quot;, fn);</code>也可以。</p><p><strong>问题延伸1：</strong></p><p><code>window.onerror</code>默认无法捕获<strong>跨域</strong>的js运行错误。捕获出来的信息如下：（基本属于无效信息）</p><p>比如说，我们的代码想引入B网站的<code>b.js</code>文件，怎么捕获它的异常呢？</p><p><strong>解决办法</strong>：在方法二的基础之上，做如下操作：</p><p>（1）在<code>b.js</code>文件里，加入如下 response header，表示允许跨域：（或者世界给静态资源<code>b.js</code>加这个 response header）</p><pre><code>    Access-Control-Allow-Origin: *</code></pre><p>（2）引入第三方的文件<code>b.js</code>时，在<code>&lt;script&gt;</code>标签中增加<code>crossorigin</code>属性；</p><p>参考链接：</p><ul><li><p><a href="https://www.jianshu.com/p/315ffe6797b8" target="_blank" rel="noopener">window.onerror的总结</a></p></li><li><p><a href="http://www.cnblogs.com/hustskyking/archive/2015/08/20/fe-monitor.html" target="_blank" rel="noopener">前端代码异常日志收集与监控</a></p></li><li><p><a href="https://foio.github.io/javascript-global-exceptions/" target="_blank" rel="noopener">捕获页面中全局Javascript异常</a></p></li></ul><p><strong>问题延伸2：</strong></p><p>只靠方式二中的<code>window.onerror</code>是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把<strong>堆栈</strong>信息作为msg打印出来，堆栈里很详细。</p><h3 id="资源加载错误的捕获方式"><a href="#资源加载错误的捕获方式" class="headerlink" title="资源加载错误的捕获方式"></a>资源加载错误的捕获方式</h3><p>上面的window.onerror只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，object.onerror捕获后就会终止（不会冒泡给window），所以window.onerror并不能捕获资源加载错误。</p><p><strong>方式1</strong>：object.onerror。img标签、script标签等节点都可以添加onerror事件，用来捕获资源加载的错误。</p><p><strong>方式2</strong>：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。</p><p>举例：</p><p>浏览器打开一个网站，在Console控制台下，输入：</p><pre><code>    performance.getEntries().forEach(function(item){console.log(item.name)})</code></pre><p>或者输入：</p><pre><code>    performance.getEntries().forEach(item=&gt;{console.log(item.name)})</code></pre><p>上面这个api，返回的是数组，既然是数组，就可以用forEach遍历。打印出来的资源就是<strong>已经成功加载</strong>的资源。；</p><p><img src="http://img.smyhvae.com/20180311_2030.png" srcset="/img/loading.gif" alt=""></p><p>再输入<code>document.getElementsByTagName(&#39;img&#39;)</code>，就会显示出所有<strong>需要加载</strong>的的img集合。</p><p>于是，<code>document.getElementsByTagName(&#39;img&#39;)</code>获取的资源数组减去通过<code>performance.getEntries()</code>获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。</p><p>这种方式非常有用，一定要记住。</p><p><strong>方式3；</strong>Error事件捕获。</p><p>源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如：</p><p><img src="http://img.smyhvae.com/20180311_2040.png" srcset="/img/loading.gif" alt=""></p><p><strong>总结：</strong>如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。</p><p>参考链接：</p><ul><li><a href="http://www.cnblogs.com/gaoning/p/7928497.html" target="_blank" rel="noopener">前端错误监控原理与实战</a> （作者的这篇文章参考了面试内容）</li></ul><h2 id="错误上报的两种方式"><a href="#错误上报的两种方式" class="headerlink" title="错误上报的两种方式"></a>错误上报的两种方式</h2><p><strong>方式一</strong>：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式）</p><p><strong>方式二：</strong>利用Image对象上报（推荐。网站的监控体系都是采用的这种方式）</p><p>方式二的实现方式如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    //通过Image对象进行错误上报    (new Image()).src = &#39;http://smyhvae.com/myPath?badjs=msg&#39;;   // myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>打开浏览器，效果如下：</p><p><img src="http://img.smyhvae.com/20180311_2055.png" srcset="/img/loading.gif" alt=""></p><p>上图中，红色那一栏表明，我的请求已经发出去了。点进去看看：</p><p><img src="http://img.smyhvae.com/20180311_2057.png" srcset="/img/loading.gif" alt=""></p><p>这种方式，不需要借助第三方的库，一行代码即可搞定。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 10-01.页面性能优化</title>
    <link href="/blog/20200313/"/>
    <url>/blog/20200313/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提升页面性能优化的方法有哪些：</p><ul><li><p>1、资源压缩合并，减少http请求</p></li><li><p>2、<strong>非核心代码异步加载</strong> –&gt; 异步加载的方式 –&gt; 异步加载的区别</p></li></ul><p>如果回答出<code>非核心代码异步加载</code>，就会层层深入。</p><ul><li>3、利用浏览器缓存 –&gt; 缓存的分类 –&gt; 缓存的原理</li></ul><p><strong>缓存</strong>是所有性能优化的方式中最重要的一步，这个一定要答好。【重要】</p><p>有的人可能会回答local storage 和session storage，其实不是这个。浏览器缓存和存储不是一回事。</p><ul><li>4、使用CDN</li></ul><p>浏览器第一次打开页面时，缓存是起不了作用的。CDN这一条，一定要说出来。</p><ul><li>5、DNS预解析</li></ul><h2 id="一、资源压缩合并，减少http请求"><a href="#一、资源压缩合并，减少http请求" class="headerlink" title="一、资源压缩合并，减少http请求"></a>一、资源压缩合并，减少http请求</h2><ul><li><p>合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩</p></li><li><p>图片较多的页面也可以使用 lazyLoad 等技术进行优化。</p></li><li><p>精灵图等</p></li></ul><h2 id="二、非核心代码异步加载"><a href="#二、非核心代码异步加载" class="headerlink" title="二、非核心代码异步加载"></a>二、非核心代码异步加载</h2><p>异步加载的方式：（这里不说框架，只说原理）</p><ul><li><p>动态脚本加载</p></li><li><p>defer</p></li><li><p>async</p></li></ul><h3 id="动态脚本加载"><a href="#动态脚本加载" class="headerlink" title="动态脚本加载"></a>动态脚本加载</h3><p>使用document.createElement创建一个script标签，即<code>document.createElement(&#39;script&#39;)</code>，然后把这个标签加载到body上面去。</p><p>参考链接：</p><ul><li><a href="https://www.jianshu.com/p/13cf23a90328" target="_blank" rel="noopener">javascript 异步加载</a> 动态脚本加载的那部分代码，看不太懂。</li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>通过异步的方式加载defer1.js文件：</p><pre><code class="html">    &lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt;</code></pre><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><blockquote><p>HTmL5新增特性。</p></blockquote><p>通过异步的方式加载async1.js文件：</p><pre><code class="html">    &lt;script src=&quot;./async1.js&quot; async&gt;&lt;/script&gt;</code></pre><h3 id="defer和async的区别"><a href="#defer和async的区别" class="headerlink" title="defer和async的区别"></a>defer和async的区别</h3><ul><li><p>defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。</p></li><li><p>async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。</p></li></ul><p>代码举例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!--通过异步的方式引入两个外部的js文件--&gt;    &lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt;    &lt;script src=&quot;./defer2.js&quot; defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    console.log(&#39;同步任务&#39;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上方打印的结果是：</p><pre><code>同步任务defer1defer2</code></pre><p>因为defer的加载是有顺序的，所以两个引入defer文件按顺序执行。如果把引入的文件改为async的方式加载，打印的结果可能是：</p><pre><code>同步任务async2async1</code></pre><p>参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000006778717" target="_blank" rel="noopener">浅谈script标签的defer和async</a></li></ul><h2 id="三、利用浏览器缓存"><a href="#三、利用浏览器缓存" class="headerlink" title="三、利用浏览器缓存"></a>三、利用浏览器缓存</h2><p><strong>缓存</strong>：资源文件（比如图片）在<strong>本地的硬盘</strong>里存有副本，浏览器下次请求的时候，可能直接从本地磁盘里读取，而不会重新请求图片的url。</p><p>缓存分为：</p><ul><li><p>强缓存</p></li><li><p>协商缓存</p></li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存</strong>：不用请求服务器，直接使用本地的缓存。</p><p>强缓存是利用 http 响应头中的<strong><code>Expires</code></strong>或<strong><code>Cache-Control</code></strong>实现的。【重要】</p><p>浏览器第一次请求一个资源时，服务器在返回该资源的同时，会把上面这两个属性放在response header中。比如：</p><p><img src="http://img.smyhvae.com/20180310_2310.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：这两个response header属性可以只启用一个，也可以同时启用。当response header中，Expires和Cache-Control同时存在时，<strong>Cache-Control的优先级高于Expires</strong>。</p><p>下面讲一下二者的区别。</p><p><strong>1、<code>Expires</code></strong>：服务器返回的<strong>绝对时间</strong>。</p><p>是较老的强缓存管理 response header。浏览器再次请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires的时间之前，就能命中缓存，否则就不行。</p><p>如果缓存没有命中，浏览器直接从服务器请求资源时，Expires Header在重新请求的时候会被更新。</p><p><strong>缺点：</strong></p><p>由于<code>Expires</code>是服务器返回的一个绝对时间，存在的问题是：服务器的事件和客户端的事件可能不一致。在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改客户端时间，就能影响缓存命中的结果。所以，在http1.1中，提出了一个新的response header，就是Cache-Control。</p><p><strong>2、<code>Cache-Control</code></strong>：服务器返回的<strong>相对时间</strong>。</p><p>http1.1中新增的 response header。浏览器第一次请求资源之后，在接下来的相对时间之内，都可以利用本地缓存。超出这个时间之后，则不能命中缓存。重新请求时，<code>Cache-Control</code>会被更新。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存</strong>：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。</p><p>当浏览器对某个资源的请求没有命中强缓存（也就是说超出时间了），就会发一个请求到服务器，验证协商缓存是否命中。</p><p>协商缓存是利用的是两对Header：</p><ul><li><p>第一对：<code>Last-Modified</code>、<code>If-Modified-Since</code></p></li><li><p>第二对：<code>ETag</code>、<code>If-None-Match</code></p></li></ul><p>ETag（Entity Tag）：被请求变量的实体值”。</p><p><strong>1、<code>Last-Modified</code>、<code>If-Modified-Since</code></strong>。过程如下：</p><p>（1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上<code>Last-Modified</code>这个 response header，这个header表示这该资源在服务器上的最后修改时间：</p><p><img src="http://img.smyhvae.com/20180311_1715.png" srcset="/img/loading.gif" alt=""></p><p>（2）浏览器再次请求这个资源时，会加上<code>If-Modified-Since</code>这个 request header，这个header的值就是上一次返回的<code>Last-Modified</code>的值：</p><p><img src="http://img.smyhvae.com/20180311_1716.png" srcset="/img/loading.gif" alt=""></p><p>（3）服务器收到第二次请求时，会比对浏览器传过来的<code>If-Modified-Since</code>和资源在服务器上的最后修改时间<code>Last-Modified</code>，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，服务器不会返回 Last-Modified 这个 response header）；如果有变化，就正常返回资源内容（继续重复整个流程）。这是服务器返回304时的response header：</p><p><img src="http://img.smyhvae.com/20180311_1720.png" srcset="/img/loading.gif" alt=""></p><p>（4）浏览器如果收到304的响应，就会从缓存中加载资源。</p><p><strong>缺点：</strong></p><p><code>Last-Modified</code>、<code>If-Modified-Since</code>一般来说都是非常可靠的，但面临的问题是：</p><ul><li><strong>服务器上的资源变化了，但是最后的修改时间却没有变化</strong>。</li></ul><ul><li>如果服务器端在一秒内修改文件两次，但产生的<code>Last-Modified</code>却只有一个值。</li></ul><p>这一对header就无法解决这种情况。于是，下面这一对header出场了。</p><p><strong>2、<code>ETag</code>、<code>If-None-Match</code></strong>。过程如下：</p><p>（1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上<code>ETag</code>这个 response header，这个header是服务器根据当前请求的资源生成的<strong>唯一标识</strong>。这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间无关，所以也就很好地补充了<code>Last-Modified</code>的不足。如下：</p><p><img src="http://img.smyhvae.com/20180311_1735.png" srcset="/img/loading.gif" alt=""></p><p>（2）浏览器再次请求这个资源时，会加上<code>If-None-Match</code>这个 request header，这个header的值就是上一次返回的<code>ETag</code>的值：</p><p><img src="http://img.smyhvae.com/20180311_1737.png" srcset="/img/loading.gif" alt=""></p><p>3）服务器第二次请求时，会对比浏览器传过来的<code>If-None-Match</code>和服务器重新生成的一个新的<code>ETag</code>，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag并无变化）。如果有变化，就正常返回资源内容（继续重复整个流程）。这是服务器返回304时的response header：</p><p><img src="http://img.smyhvae.com/20180311_1740.png" srcset="/img/loading.gif" alt=""></p><p>（4）浏览器如果收到304的响应，就会从缓存中加载资源。</p><p>提示：如果面试官问你：与浏览器缓存相关的http header有哪些？你能写出来吗？这是一个亮点。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a>[荐]</li></ul><h2 id="四、使用CDN"><a href="#四、使用CDN" class="headerlink" title="四、使用CDN"></a>四、使用CDN</h2><p>怎么最快地让用户请求资源。一方面是让资源在传输的过程中变小，另外就是CDN。</p><p>要注意，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的，使用CDN，效果就很明显。</p><h2 id="五、DNS预解析（dns-prefetch）"><a href="#五、DNS预解析（dns-prefetch）" class="headerlink" title="五、DNS预解析（dns-prefetch）"></a>五、DNS预解析（dns-prefetch）</h2><p>通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。</p><p><strong>第一步</strong>：打开或关闭DNS预解析</p><p>你可以通过在服务器端发送 X-DNS-Prefetch-Control 报头。或是在文档中使用值为 http-equiv 的meta标签：</p><pre><code class="html">    &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></pre><p>需要说明的是，在一些高级浏览器中，页面中所有的超链接（<code>&lt;a&gt;</code>标签），默认打开了DNS预解析。但是，如果页面中采用的https协议，很多浏览器是默认关闭了超链接的DNS预解析。如果加了上面这行代码，则表明强制打开浏览器的预解析。（如果你能在面试中把这句话说出来，则一定是你出彩的地方）</p><p><strong>第二步</strong>：对指定的域名进行DNS预解析</p><p>如果我们将来可能从 smyhvae.com 获取图片或音频资源，那么可以在文档顶部的</p><head>标签中加入以下内容：<p></p><pre><code class="html">    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://www.smyhvae.com/&quot;&gt;</code></pre><p>当我们从该 URL 请求一个资源时，就不再需要等待 DNS 解析的过程。该技术对使用第三方资源特别有用。</p><p>参考链接：</p><ul><li><p><a href="http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/" target="_blank" rel="noopener">前端性能优化 - 资源预加载</a>[荐]</p></li><li><p><a href="https://www.xuanfengge.com/dns-prefetching-analysis.html" target="_blank" rel="noopener">DNS预解析详解</a></p></li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote></head>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 09=02.js运行机制：异步和单线程</title>
    <link href="/blog/20200312/"/>
    <url>/blog/20200312/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面试时，关于<code>同步和异步</code>，可能会问以下问题：</p><ul><li><p>同步和异步的区别是什么？分别举一个同步和异步的例子</p></li><li><p>一个关于 setTimeout 的笔试题</p></li><li><p>前端使用异步的场景哪些？</p></li></ul><p>面试时，关于<code>js运行机制</code>，需要注意以下几个问题：</p><ul><li><p>如何理解JS的<strong>单线程</strong></p></li><li><p>什么是<strong>任务队列</strong></p></li><li><p>什么是 EventLoop</p></li><li><p>理解哪些语句会放入异步任务队列</p></li><li><p>理解语句放入异步任务队列的<strong>时机</strong></p></li></ul><h2 id="JS的异步和单线程"><a href="#JS的异步和单线程" class="headerlink" title="JS的异步和单线程"></a>JS的异步和单线程</h2><blockquote><p>因为是单线程，所以必须异步。</p></blockquote><p>我们通过题目来解释以下。</p><h3 id="题目一：异步"><a href="#题目一：异步" class="headerlink" title="题目一：异步"></a>题目一：异步</h3><p>现有如下代码：</p><pre><code class="javascript">    console.log(1);    setTimeout(function () {        console.log(2);    }, 1000);    console.log(3);    console.log(4);</code></pre><p>上面的代码中，我们很容易知道，打印的顺序是<code>1，3，4，2</code>。因为你会想到，要等一秒之后再打印<code>2</code>。</p><p>可如果我把延时的时间从<code>1000</code>改成<code>0</code>：</p><pre><code class="javascript">    console.log(1);    setTimeout(function () {        console.log(2);    }, 0);    console.log(3);    console.log(4);</code></pre><p>上方代码中，打印的顺序仍然是<code>1，3，4，2</code>。这是为什么呢？我们来分析一下。</p><p><strong>总结：</strong></p><p>js 是单线程（同一时间只能做一件事），而且有一个<strong>任务队列</strong>：全部的同步任务执行完毕后，再来执行异步任务。第一行代码和最后一行代码是同步任务；但是，<strong><code>setTimeout</code>是异步任务</strong>。</p><p>于是，执行的顺序是：</p><ul><li><p>先执行同步任务<code>console.log(1)</code></p></li><li><p>遇到异步任务<code>setTimeout</code>，要<strong>挂起</strong></p></li><li><p>执行同步任务<code>console.log(3)</code></p></li><li><p><strong>全部的同步任务执行完毕后，再来执行异步任务</strong><code>console.log(2)</code>。</p></li></ul><p>很多人会把这个题目答错，这是因为他们不懂 js 的运行机制。</p><p>注意上面那句话：同步任务执行完毕后，再来执行异步任务。也就是说，<strong>如果同步任务没有执行完，异步任务是不会执行的</strong>。为了解释这句话，我们来看下面这个例子。</p><h3 id="题目二：异步"><a href="#题目二：异步" class="headerlink" title="题目二：异步"></a>题目二：异步</h3><p>现有如下代码：</p><pre><code class="javascript">    console.log(&#39;A&#39;);    while (1) {    }    console.log(&#39;B&#39;);</code></pre><p>我们很容易想到，上方代码的打印结果是<code>A</code>，因为while是同步任务，代码会陷入死循环里出不来，自然也就无法打印<code>B</code>。可如果我把代码改成下面的样子：</p><pre><code class="javascript">    console.log(&#39;A&#39;);    setTimeout(function () {        console.log(&#39;B&#39;);    })    while (1) {    }</code></pre><p>上方代码的打印结果仍然是<code>A</code>。因为while是同步任务，setTimeout是异步任务，所以还是那句话：<strong>如果同步任务没有执行完，队列里的异步任务是不会执行的</strong>。</p><h3 id="题目三：同步"><a href="#题目三：同步" class="headerlink" title="题目三：同步"></a>题目三：同步</h3><pre><code class="javascript">    console.log(&#39;A&#39;);    alert(&#39;haha&#39;); //1秒之后点击确认    console.log(&#39;B&#39;);</code></pre><p><code>alert</code>函数是同步任务，我只有点击了确认，才会继续打印<code>B</code>。</p><h3 id="同步和异步的对比"><a href="#同步和异步的对比" class="headerlink" title="同步和异步的对比"></a>同步和异步的对比</h3><p>我们在上面列举了异步和同步的例子。现在来描述一下区别：【重要】</p><p>因为<code>setTimeout</code>是<strong>异步任务</strong>，所以程序并不会卡在那里，而是继续向下执行（即使settimeout设置了倒计时一万秒）；但是<code>alert</code>函数是<strong>同步</strong>任务，程序会<strong>卡在那里</strong>，如果它没有执行，后面的也不会执行（卡在那里，自然也就造成了<strong>阻塞</strong>）。</p><h3 id="前端使用异步的场景"><a href="#前端使用异步的场景" class="headerlink" title="前端使用异步的场景"></a>前端使用异步的场景</h3><p>什么时候需要<strong>等待</strong>，就什么时候用异步。</p><ul><li><p>定时任务：setTimeout（定时炸弹）、setInterval（循环执行）</p></li><li><p>网络请求：ajax请求、动态<code>&lt;img&gt;</code>加载</p></li><li><p>事件绑定（比如说，按钮绑定点击事件之后，用户爱点不点。我们不可能卡在按钮那里，什么都不做。所以，应该用异步）</p></li><li><p>ES6中的Promise</p></li></ul><p>代码举例：</p><pre><code class="javascript">    console.log(&#39;start&#39;);    var img = document.createElement(&#39;img&#39;);    img.onload = function () {        console.log(&#39;loaded&#39;);    }    img.src = &#39;/xxx.png&#39;;    console.log(&#39;end&#39;);</code></pre><p>上图中，先打印<code>start</code>，然后执行<code>img.src = &#39;/xxx.png&#39;</code>，然后打印<code>end</code>，最后打印<code>loaded</code>。</p><h2 id="任务队列和Event-Loop（事件循环）"><a href="#任务队列和Event-Loop（事件循环）" class="headerlink" title="任务队列和Event Loop（事件循环）"></a>任务队列和Event Loop（事件循环）</h2><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>总结：<strong>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制</strong>。【重要】</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p><img src="http://img.smyhvae.com/20180310_1840.png" srcset="/img/loading.gif" alt=""></p><p>在理解Event Loop时，要理解两句话：</p><ul><li><p>理解哪些语句会放入异步任务队列</p></li><li><p>理解语句放入异步任务队列的<strong>时机</strong></p></li></ul><h3 id="容易答错的题目"><a href="#容易答错的题目" class="headerlink" title="容易答错的题目"></a>容易答错的题目</h3><pre><code class="javascript">    for (var i = 0; i &lt; 3; i++) {        setTimeout(function () {            console.log(i);        }, 1000);    }</code></pre><p>很多人以为上面的题目，答案是<code>0,1,2,3</code>。其实，正确的答案是：<code>3,3,3,3</code>。</p><p>分析：for 循环是同步任务，setTimeout是异步任务。for循环每次遍历的时候，遇到settimeout，就先暂留着，等同步任务全部执行完毕（此时，i已经等于3了），再执行异步任务。</p><p>我们把上面的题目再加一行代码。最终代码如下：</p><pre><code class="javascript">    for (var i = 0; i &lt; 3; i++) {        setTimeout(function () {            console.log(i);        }, 1000);    }    console.log(i);</code></pre><p>如果我们约定，用箭头表示其前后的两次输出之间有 1 秒的时间间隔，而逗号表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？可能会有两种答案：</p><ul><li><p>A. 60% 的人会描述为：<code>3 -&gt; 3 -&gt; 3 -&gt; 3</code>，即每个 3 之间都有 1 秒的时间间隔；</p></li><li><p>B. 40% 的人会描述为：<code>3 -&gt; 3,3,3</code>，即第 1 个 3 直接输出，1 秒之后，连续输出 3 个 3。</p></li></ul><p>循环执行过程中，几乎同时设置了 3 个定时器，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B。</p><p>上面这个题目的参考链接：</p><ul><li><p><a href="https://juejin.im/post/58cf180b0ce4630057d6727c" target="_blank" rel="noopener">80% 应聘者都不及格的 JS 面试题</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="noopener">深入浅出Javascript事件循环机制(上)</a></p></li></ul><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 09-01.浏览器渲染机制</title>
    <link href="/blog/20200311/"/>
    <url>/blog/20200311/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>接下来的几篇文章，讲一下二面的内容。</p></blockquote><p><strong>二面的内容：</strong></p><ul><li><p>渲染机制</p></li><li><p>JS 运行机制</p></li><li><p>页面性能</p></li><li><p>错误监控</p></li></ul><p>本文接下来讲渲染机制。</p><p><strong>渲染机制</strong>包括的内容：</p><ul><li><p>什么是DOCTYPE及作用</p></li><li><p>浏览器渲染过程</p></li></ul><p>面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的渲染过程。</p><ul><li>Reflow：重排</li></ul><p>面试官问完了渲染机制，一般会紧接着问重排Reflow，你可千万别说你没听过。</p><ul><li><p>Repaint：重绘</p></li><li><p>Layout：布局</p></li></ul><p>这里的Layout指的是浏览器的Layout。</p><h2 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>DTD</strong>（Document Type Definition）：文档类型定义。</p><p>是一系列的语法规则，用来定义XML或者(X)HTML文件类型。<strong>浏览器会使用DTD来判断文本类型</strong>，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我）</p><p><strong>DOCTYPE</strong>：用来声明DTD规范。</p><p>一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE就是用来声明DTD的）</p><h3 id="常见的DOCTYPE声明有几种"><a href="#常见的DOCTYPE声明有几种" class="headerlink" title="常见的DOCTYPE声明有几种"></a>常见的DOCTYPE声明有几种</h3><blockquote><p>面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。</p></blockquote><p>1、<strong>HTML 4.01 Strict</strong>：（严格的）</p><pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></pre><p>PS：该DTD包含所有的HTML元素和属性，但不包括展示性的和弃用的元素（比如 font、u下划线等，这些是被废弃了的）。</p><p>2、<strong>HTML 4.01 Transitional</strong>：（传统的）</p><pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></pre><p>PS：该DTD包含所有的HTML元素和属性，但包括展示性的和弃用的元素（比如 font、u下划线等）。</p><p>3、HTML 5：</p><pre><code class="html">&lt;!DOCTYPE html&gt;</code></pre><p><strong>总结：</strong></p><p>面试时，不会让你写出 HTML 4.01的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。</p><p>面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5的写法是<code>&lt;!DOCTYPE html&gt;</code>。</p><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p>浏览器的渲染过程非常复杂，但是面试只用说几句话就行了，不然太耗时间。如何快速简洁地描述清楚，是关键。</p><p><img src="http://img.smyhvae.com/20180310_1257.png" srcset="/img/loading.gif" alt=""></p><p>这里先解释一下几个概念，方便大家理解：</p><ul><li><p>DOM Tree：浏览器将HTML解析成树形的数据结构（DOM 树）。</p></li><li><p>CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</p></li><li><p>Render Tree: DOM和CSSOM合并后生成Render Tree。（虽然有了Render Tree，但并不知道节点的位置，需要依靠接下来的layout）</p></li><li><p>layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去<strong>计算出每个节点在屏幕中的位置</strong>(宽高、颜色等)。</p></li><li><p>painting：按照算出来的规则，通过显卡，把内容画到屏幕上。</p></li><li><p>display：打击看到的最终效果。</p></li></ul><p>参考链接：</p><ul><li><a href="http://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noopener">浏览器渲染原理及流程[荐]</a></li></ul><h2 id="Reflow：重排"><a href="#Reflow：重排" class="headerlink" title="Reflow：重排"></a>Reflow：重排</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>重排 Reflow</strong>：DOM结果中的各个元素都有自己的盒子（模型），这些都需要浏览器<strong>根据各种样式来计算，并根据计算结果将元素放在它该出现的位置</strong>，这个过程称之为Reflow。</p><h3 id="什么时候触发-Reflow"><a href="#什么时候触发-Reflow" class="headerlink" title="什么时候触发 Reflow"></a>什么时候触发 Reflow</h3><ul><li><p>增加、删除、修改DOM节点时，会导致 Reflow 或 Repaint。</p></li><li><p>移动DOM的位置，或是加个动画的时候</p></li><li><p>修改CSS样式时（宽高、display 为none等，都是通过css样式来修改的）</p></li><li><p>当用户Resize窗口时（移动端没有这个问题），或是滚动的时候，<strong>有可能</strong>会触发（具体要看浏览器的规则）。</p></li><li><p>修改网页的默认字体时（这个影响非常严重）。</p></li></ul><p><strong>面试总结：</strong></p><p>首先要答出 Reflow 定义；其次，什么时候触发，至少要答出两条。更进一步，面试官可能还会问你<strong>怎么避免reflow</strong>，这个自己去查查吧。</p><h2 id="Repaint：重绘"><a href="#Repaint：重绘" class="headerlink" title="Repaint：重绘"></a>Repaint：重绘</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>Repaint重绘制：</strong>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为 Repaint。</p><p>说白了，页面要呈现的内容，统统画在屏幕上，这就叫 Repaint。</p><h3 id="什么时候触发-Repaint"><a href="#什么时候触发-Repaint" class="headerlink" title="什么时候触发 Repaint"></a>什么时候触发 Repaint</h3><ul><li><p>DOM改动</p></li><li><p>CSS改动</p></li></ul><p>其实，就是判断当前呈现的内容是否发生变化（无论这个变化是通过DOM改动还是CSS改动）。只要页面显示的内容不一样了，肯定要 Repaint。</p><p><strong>面试总结：</strong></p><p>面试官经常会问：“如何<strong>尽量减少</strong>Repaint的频率？”</p><p>注意， reflow是问“怎么避免”，repaint是问“怎么减少”。Repaint是无法避免的，否则就成了静态页面了。</p><p><strong>答案</strong>：</p><p>（1）如果需要创建多个DOM节点，可以使用<strong>DocumentFragment</strong>创建完，然后一次性地加入document。（加一个节点，就repaint一次，不太好）</p><p>（2）将元素的display设置为”none”，完成修改后再把display修改为原来的值。</p><p>参考链接：<a href="http://blog.csdn.net/liaozhongping/article/details/47057889" target="_blank" rel="noopener">如何减少浏览器repaint和reflow ?</a></p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 08-算法问题</title>
    <link href="/blog/20200310/"/>
    <url>/blog/20200310/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>算法主要包括：</p><ul><li>1、排序</li></ul><p>排序一定要准备。</p><ul><li>2、堆栈、队列、链表</li></ul><p>队列和链表可以不准备，但是堆栈一定要准备。</p><p>一个小技巧：JS的数组本身就具备堆栈和队列的特性。比如：top、push、shift、unshift这四个api，本身就帮我们实现了堆栈和队列。</p><p>堆栈：先进后出。</p><ul><li>3、递归</li></ul><p>递归是一定不能偷懒的。算法比较难的时候，一般要用到递归。</p><ul><li>4、波兰式和逆波兰式</li></ul><p><strong>总结：</strong></p><p>比如阿里，如果基础题答的很好，但是算法不会，那可能通不过。</p><p>还有金融类的，必考算法。比如阿里云，里面的业务就是算法的，所以肯定考算法。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>上面的排序这么多，我们要记住下面这三个：</p><ul><li><p>快速排序：<a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009426421</a></p></li><li><p>选择排序：<a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009366805</a></p></li><li><p>希尔排序：<a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009461832</a></p></li></ul><p>如果你还要学一个，那就是<strong>冒泡排序</strong>。</p><p>题目中，会给你一个算法题， 排序只是其中一个步骤。而且，并不会指定你要求用哪种排序。</p><h2 id="堆栈、队列、链表"><a href="#堆栈、队列、链表" class="headerlink" title="堆栈、队列、链表"></a>堆栈、队列、链表</h2><p>参考链接：</p><ul><li><a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li></ul><p>上面这个链接是转载的。原创博主的系列文章是：</p><ul><li><a href="http://huang303513.github.io/2016/12/08/Javascript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E4%B8%80).html" target="_blank" rel="noopener">数组、队列、链表</a></li></ul><ul><li><a href="http://huang303513.github.io/2016/12/19/Javascript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E5%9B%9B).html" target="_blank" rel="noopener">排序</a></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">JavaScript中的递归</a></li></ul><p>递归理解起来不难，但是用的时候很难，因为你没抓住他的本质。递归的终止条件是什么？参数是怎么传递的？一定要搞清楚。</p><p>很多人说：“我知道这道题是考递归，但是我就是不知道该怎么写”。这个面试官很无奈。</p><h2 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="headerlink" title="波兰式和逆波兰式"></a>波兰式和逆波兰式</h2><blockquote><p>如果复习时间很紧张，这部分也不用准备了。也不是所有的公司都会问。</p></blockquote><p>推荐链接：</p><ul><li><p>理论：<a href="http://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenying99/p/3675876.html</a></p></li><li><p>源码：<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果实在答不来，就说，这个算法我不是很会，只知道一些基本概念。</p><p>如果第一面就碰到算法题，这个公司不用去了。说明这个公司是招算法的，不是招前端的。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 07-安全问题：CSRF和XSS</title>
    <link href="/blog/20200309/"/>
    <url>/blog/20200309/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面试中的安全问题，明确来说，就两个方面：</p><ul><li><p>CSRF：基本概念、攻击方式、防御措施</p></li><li><p>XSS：基本概念、攻击方式、防御措施</p></li></ul><p>这两个问题，一般不会问太难。</p><p>有人问：SQL注入算吗？答案：这个其实跟前端的关系不是很大。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>问的不难，一般问：</p><ul><li><p>CSRF的基本概念、缩写、全称</p></li><li><p>攻击原理</p></li><li><p>防御措施</p></li></ul><p>如果把<strong>攻击原理</strong>和<strong>防御措施</strong>掌握好，基本没什么问题。</p><h3 id="1、CSRF的基本概念、缩写、全称"><a href="#1、CSRF的基本概念、缩写、全称" class="headerlink" title="1、CSRF的基本概念、缩写、全称"></a>1、CSRF的基本概念、缩写、全称</h3><p>CSRF（Cross-site request forgery）：<strong>跨站请求伪造</strong>。</p><p>PS：中文名一定要记住。英文全称，如果记不住也拉倒。</p><h3 id="2、CSRF的攻击原理"><a href="#2、CSRF的攻击原理" class="headerlink" title="2、CSRF的攻击原理"></a>2、CSRF的攻击原理</h3><p><img src="http://img.smyhvae.com/20180307_1735.png" srcset="/img/loading.gif" alt=""></p><p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。</p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：</p><p>（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）</p><p>（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。</p><p>我们在讲CSRF时，一定要把上面的两点说清楚。</p><p>温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。</p><p>举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。</p><h3 id="3、CSRF如何防御"><a href="#3、CSRF如何防御" class="headerlink" title="3、CSRF如何防御"></a>3、CSRF如何防御</h3><p><strong>方法一、Token 验证：</strong>（用的最多）</p><p>（1）服务器发送给客户端一个token；</p><p>（2）客户端提交的表单中带着这个token。</p><p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p><p><strong>方法二：隐藏令牌：</strong></p><p>把 token 隐藏在 http 的 head头中。</p><p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p><p><strong>方法三、Referer 验证：</strong></p><p>Referer 指的是页面请求来源。意思是，<strong>只接受本站的请求，服务器才做响应</strong>；如果不是，就拦截。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="1、XSS的基本概念"><a href="#1、XSS的基本概念" class="headerlink" title="1、XSS的基本概念"></a>1、XSS的基本概念</h3><p>XSS（Cross Site Scripting）：<strong>跨域脚本攻击</strong>。</p><p>接下来，我们详细讲一下 XSS 的内容。</p><blockquote><p>预备知识：HTTP、Cookie、Ajax。</p></blockquote><h3 id="XSS的攻击原理"><a href="#XSS的攻击原理" class="headerlink" title="XSS的攻击原理"></a>XSS的攻击原理</h3><p>XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。</p><p>最后导致的结果可能是：</p><ul><li><p>盗用Cookie</p></li><li><p>破坏页面的正常结构，插入广告等恶意内容</p></li><li><p>D-doss攻击</p></li></ul><h3 id="XSS的攻击方式"><a href="#XSS的攻击方式" class="headerlink" title="XSS的攻击方式"></a>XSS的攻击方式</h3><ul><li>1、反射型</li></ul><p>发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</p><ul><li>2、存储型</li></ul><p>存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。</p><h3 id="XSS的防范措施（encode-过滤）"><a href="#XSS的防范措施（encode-过滤）" class="headerlink" title="XSS的防范措施（encode + 过滤）"></a>XSS的防范措施（encode + 过滤）</h3><p>XSS的防范措施主要有三个：</p><p><strong>1、编码</strong>：</p><p>对用户输入的数据进行<code>HTML Entity</code>编码。</p><p>如上图所示，把字符转换成 转义字符。</p><p>Encode的作用是将<code>$var</code>等一些字符进行转化，使得浏览器在最终输出结果上是一样的。</p><p>比如说这段代码：</p><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。</p><p>进行编码处理之后，L在浏览器中的显示结果就是<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。</p><p>参考链接：<a href="https://www.jianshu.com/p/599fcd03fd3b" target="_blank" rel="noopener">4类防御XSS的有效方法</a></p><p><strong>2、过滤：</strong></p><ul><li><p>移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言之，过滤掉一些不安全的内容）</p></li><li><p>移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</p></li></ul><p><strong>3、校正</strong></p><ul><li><p>避免直接对<code>HTML Entity</code>进行解码。</p></li><li><p>使用<code>DOM Parse</code>转换，校正不配对的DOM标签。</p></li></ul><p>备注：我们应该去了解一下<code>DOM Parse</code>这个概念，它的作用是把文本解析成DOM结构。</p><p>比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。</p><p><strong>还有一种简洁的答案：</strong></p><p>首先是encode，如果是富文本，就白名单。</p><h2 id="CSRF-和-XSS-的区别"><a href="#CSRF-和-XSS-的区别" class="headerlink" title="CSRF 和 XSS 的区别"></a>CSRF 和 XSS 的区别</h2><p>面试官还可能喜欢问二者的区别。</p><p>区别一：</p><ul><li><p>CSRF：需要用户先登录网站A，获取 cookie。</p></li><li><p>XSS：不需要登录。</p></li></ul><p>区别二：（原理的区别）</p><ul><li><p>CSRF：是利用网站A本身的漏洞，去请求网站A的api。</p></li><li><p>XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="XSS-1"><a href="#XSS-1" class="headerlink" title="XSS"></a>XSS</h3><p>关于XSS，推荐几个网站：</p><ul><li><a href="http://html5sec.org/" target="_blank" rel="noopener">http://html5sec.org/</a></li></ul><p>里面列出了很多XSS的例子，可以长见识。如果你专门研究XSS，可以看看。</p><ul><li><a href="http://www.freebuf.com/author/black-hole" target="_blank" rel="noopener">FreeBuf网站上的专栏作者：Black-Hole</a></li></ul><p>比如，他的第一篇文章就讲到了<a href="http://www.freebuf.com/articles/web/40520.html" target="_blank" rel="noopener">XSS的原理分析与解剖</a>。有句话摘抄如下：弹窗只是测试xss的存在性和使用性。</p><p>比如，这个人还有篇文章写<a href="http://www.freebuf.com/articles/web/107207.html" target="_blank" rel="noopener">自动化检测CSRF（第一章）</a>。大公司做网站，一般会做嗅探服务（比如自动化工具做CSRF的检测、自动化的方式控制安全风险）。</p><p>另外，可能还有些工具，可以扫描代码本身有没有一些安全问题。</p><ul><li><a href="https://github.com/cure53" target="_blank" rel="noopener">GitHub | Cure53</a></li></ul><p>这是GitHub上的一个德国组织。</p><p>上面的项目都跟安全相关，有些仓库是可以直接运行的。如果你不需要定制，就可以直接用别人的，没必要自己写XSS库、XSS的过滤之类的，避免麻烦。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 06-跨域通信类</title>
    <link href="/blog/20200308/"/>
    <url>/blog/20200308/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本章起，对代码的要求没之前那么高了，但是，要求你对知识面的掌握要足够宽。</p><p>前端通信类的问题，主要包括以下内容：</p><ul><li>1、什么是<strong>同源策略</strong>及限制</li></ul><p>同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。</p><ul><li>2、<strong>前后端如何通信</strong></li></ul><p>如果你不准备，估计也就只能说出ajax。这个可以考察出知识面。</p><ul><li>3、如何创建<strong>Ajax</strong></li></ul><p>Ajax在前后端通信中经常用到。做业务时，可以借助第三方的库，比如vue框架里的库、jQuery也有封装好的方法。但如果让你用原生的js去实现，该怎么做？</p><p>这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。</p><ul><li>4、<strong>跨域通信</strong>的几种方式</li></ul><p>这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、<strong>跨域有几种方式</strong>。</p><p>下面分别讲解。</p><h2 id="同源策略的概念和具体限制"><a href="#同源策略的概念和具体限制" class="headerlink" title="同源策略的概念和具体限制"></a>同源策略的概念和具体限制</h2><p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）</p><p>具体解释：</p><p>（1）<code>源</code>包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则<code>源</code>不同，那就是跨域了。</p><p>（2）<code>限制</code>：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）</p><ul><li><p>Cookie、LocalStorage和IndexDB无法获取。</p></li><li><p>无法获取和操作DOM。</p></li><li><p>不能发送Ajax请求。我们要注意，Ajax只适合<strong>同源</strong>的通信。</p></li></ul><h2 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h2><p>主要有以下几种方式：</p><ul><li><p>Ajax：不支持跨域。</p></li><li><p>WebSocket：不受同源策略的限制，支持跨域。</p></li><li><p>CORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：<strong>同时支持同源和跨域的Ajax</strong>。</p></li></ul><h2 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h2><blockquote><p>关于Ajax请求，可以看本人的基础文章：<a href="https://github.com/smyhvae/Web/blob/master/08-Ajax/02-Ajax%E5%85%A5%E9%97%A8%E5%92%8C%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82.md" target="_blank" rel="noopener">Ajax入门和发送http请求</a></p></blockquote><p>在回答 Ajax 的问题时，要回答以下几个方面：</p><ul><li><p>1、XMLHttpRequest 的工作原理</p></li><li><p>2、兼容性处理</p></li></ul><p>XMLHttpRequest只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。</p><ul><li><p>3、事件的触发条件</p></li><li><p>4、事件的触发顺序</p></li></ul><p>XMLHttpRequest有很多触发事件，每个事件是怎么触发的。</p><h3 id="发送-Ajax-请求的五个步骤（XMLHttpRequest的工作原理）"><a href="#发送-Ajax-请求的五个步骤（XMLHttpRequest的工作原理）" class="headerlink" title="发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）"></a>发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）</h3><p>（1）创建XMLHttpRequest 对象。</p><p>（2）使用open方法设置请求的参数。open(method, url, 是否异步)。</p><p>（3）发送请求。</p><p>（4）注册事件。 注册onreadystatechange事件，状态改变时就会调用。</p><p>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</p><p>（5）获取返回的数据，更新UI。</p><h3 id="发送-get-请求和-post-请求"><a href="#发送-get-请求和-post-请求" class="headerlink" title="发送 get 请求和 post 请求"></a>发送 get 请求和 post 请求</h3><p>get请求举例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送get_ajax请求&quot; id=&#39;btnAjax&#39;&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 绑定点击事件    document.querySelector(&#39;#btnAjax&#39;).onclick = function () {        // 发送ajax 请求 需要 五步        // （1）创建异步对象        var ajaxObj = new XMLHttpRequest();        // （2）设置请求的参数。包括：请求的方法、请求的url。        ajaxObj.open(&#39;get&#39;, &#39;02-ajax.php&#39;);        // （3）发送请求        ajaxObj.send();        //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。        //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。        ajaxObj.onreadystatechange = function () {            // 为了保证 数据 完整返回，我们一般会判断 两个值            if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status == 200) {                // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的                // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示                console.log(&#39;数据返回成功&#39;);                // 数据是保存在 异步对象的 属性中                console.log(ajaxObj.responseText);                // 修改页面的显示                document.querySelector(&#39;h1&#39;).innerHTML = ajaxObj.responseText;            }        }    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>post 请求举例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送put_ajax请求&quot; id=&#39;btnAjax&#39;&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 异步对象    var xhr = new XMLHttpRequest();    // 设置属性    xhr.open(&#39;post&#39;, &#39;02.post.php&#39;);    // 如果想要使用post提交数据,必须添加此行    xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);    // 将数据通过send方法传递    xhr.send(&#39;name=fox&amp;age=18&#39;);    // 发送并接受返回值    xhr.onreadystatechange = function () {        // 这步为判断服务器是否正确响应        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            alert(xhr.responseText);        }    };&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h3><p>注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。</p><p>readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化）</p><ul><li><p>0: 请求未初始化</p></li><li><p>1: 服务器连接已建立</p></li><li><p>2: 请求已接收</p></li><li><p>3: 请求处理中</p></li><li><p>4: 请求已完成，且响应已就绪</p></li></ul><h3 id="事件的触发条件"><a href="#事件的触发条件" class="headerlink" title="事件的触发条件"></a>事件的触发条件</h3><p><img src="http://img.smyhvae.com/20180307_1443.png" srcset="/img/loading.gif" alt=""></p><h3 id="事件的触发顺序"><a href="#事件的触发顺序" class="headerlink" title="事件的触发顺序"></a>事件的触发顺序</h3><p><img src="http://img.smyhvae.com/20180307_1445.png" srcset="/img/loading.gif" alt=""></p><p>上图的参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000004322487" target="_blank" rel="noopener">你真的会使用XMLHttpRequest吗？</a></li></ul><h3 id="实际开发中用的-原生Ajax请求"><a href="#实际开发中用的-原生Ajax请求" class="headerlink" title="实际开发中用的 原生Ajax请求"></a>实际开发中用的 原生Ajax请求</h3><pre><code class="javascript">    var util = {};    //获取 ajax 请求之后的json    util.json = function (options) {        var opt = {            url: &#39;&#39;,            type: &#39;get&#39;,            data: {},            success: function () {            },            error: function () {            },        };        util.extend(opt, options);        if (opt.url) {            //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api            var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);            var data = opt.data,                url = opt.url,                type = opt.type.toUpperCase();            dataArr = [];        }        for (var key in data) {            dataArr.push(key + &#39;=&#39; + data[key]);        }        if (type === &#39;GET&#39;) {            url = url + &#39;?&#39; + dataArr.join(&#39;&amp;&#39;);            xhr.open(type, url.replace(/\?$/g, &#39;&#39;), true);            xhr.send();        }        if (type === &#39;POST&#39;) {            xhr.open(type, url, true);            // 如果想要使用post提交数据,必须添加此行            xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);            xhr.send(dataArr.join(&#39;&amp;&#39;));        }        xhr.onload = function () {            if (xhr.status === 200 || xhr.status === 304) { //304表示：用缓存即可。206表示获取媒体资源的前面一部分                var res;                if (opt.success &amp;&amp; opt.success instanceof Function) {                    res = xhr.responseText;                    if (typeof res === &#39;string&#39;) {                        res = JSON.parse(res);  //将字符串转成json                        opt.success.call(xhr, res);                    }                }            } else {                if (opt.error &amp;&amp; opt.error instanceof Function) {                    opt.error.call(xhr, res);                }            }        };    }</code></pre><p>Ajax 的推荐链接：<a href="https://segmentfault.com/a/1190000006669043" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006669043</a></p><h2 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h2><p>方式如下：</p><ul><li><p>1、JSONP</p></li><li><p>2、WebSocket</p></li><li><p>3、CORS</p></li><li><p>4、Hash</p></li><li><p>5、postMessage</p></li></ul><p>上面这五种方式，在面试时，都要说出来。</p><h3 id="1、JSONP"><a href="#1、JSONP" class="headerlink" title="1、JSONP"></a>1、JSONP</h3><p>面试会问：JSONP的原理是什么？怎么实现的？</p><p>在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。</p><p><strong>JSONP的原理</strong>：通过<code>&lt;script&gt;</code>标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过<code>&lt;script&gt;</code>标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。</p><p><strong>JSONP的实现：</strong></p><p>比如说，客户端这样写：</p><pre><code class="html">    &lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt;</code></pre><p>上面的src中，<code>data=name</code>是get请求的参数，<code>myjsonp</code>是和后台约定好的函数名。<br>服务器端这样写：</p><pre><code class="bash">        myjsonp({            data: {}        })</code></pre><p>于是，本地要求创建一个myjsonp 的<strong>全局函数</strong>，才能将返回的数据执行出来。</p><p><strong>实际开发中，前端的JSONP是这样实现的：</strong></p><pre><code class="html">&lt;script&gt;    var util = {};    //定义方法：动态创建 script 标签    /**     * [function 在页面中注入js脚本]     * @param  {[type]} url     [description]     * @param  {[type]} charset [description]     * @return {[type]}         [description]     */    util.createScript = function (url, charset) {        var script = document.createElement(&#39;script&#39;);        script.setAttribute(&#39;type&#39;, &#39;text/javascript&#39;);        charset &amp;&amp; script.setAttribute(&#39;charset&#39;, charset);        script.setAttribute(&#39;src&#39;, url);        script.async = true;        return script;    };    /**     * [function 处理jsonp]     * @param  {[type]} url      [description]     * @param  {[type]} onsucess [description]     * @param  {[type]} onerror  [description]     * @param  {[type]} charset  [description]     * @return {[type]}          [description]     */    util.jsonp = function (url, onsuccess, onerror, charset) {        var callbackName = util.getName(&#39;tt_player&#39;); //事先约定好的 函数名        window[callbackName] = function () {      //根据回调名称注册一个全局的函数            if (onsuccess &amp;&amp; util.isFunction(onsuccess)) {                onsuccess(arguments[0]);            }        };        var script = util.createScript(url + &#39;&amp;callback=&#39; + callbackName, charset);   //动态创建一个script标签        script.onload = script.onreadystatechange = function () {   //监听加载成功的事件，获取数据            if (!script.readyState || /loaded|complete/.test(script.readyState)) {                script.onload = script.onreadystatechange = null;                // 移除该script的 DOM 对象                if (script.parentNode) {                    script.parentNode.removeChild(script);                }                // 删除函数或变量                window[callbackName] = null;  //最后不要忘了删除            }        };        script.onerror = function () {            if (onerror &amp;&amp; util.isFunction(onerror)) {                onerror();            }        };        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去    };&lt;/script&gt;</code></pre><h3 id="2、WebSocket"><a href="#2、WebSocket" class="headerlink" title="2、WebSocket"></a>2、WebSocket</h3><p>WebSocket的用法如下：</p><pre><code class="javascript">    //    var ws = new WebSocket(&#39;wss://echo.websocket.org&#39;); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。    //把请求发出去    ws.onopen = function (evt) {        console.log(&#39;Connection open ...&#39;);        ws.send(&#39;Hello WebSockets!&#39;);    };    //对方发消息过来时，我接收    ws.onmessage = function (evt) {        console.log(&#39;Received Message: &#39;, evt.data);        ws.close();    };    //关闭连接    ws.onclose = function (evt) {        console.log(&#39;Connection closed.&#39;);    };</code></pre><p>Websocket的推荐链接：<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p><p>面试一般不会让你写这个代码，一般是考察你是否了解 WebSocket概念，知道有这么回事即可。</p><h3 id="3、CORS"><a href="#3、CORS" class="headerlink" title="3、CORS"></a>3、CORS</h3><p>CORS 可以理解成是<strong>既可以同步、也可以异步</strong>的Ajax。</p><p>fetch 是一个比较新的API，用来实现CORS通信。用法如下：</p><pre><code class="javascript">      // url（必选），options（可选）      fetch(&#39;/some/url/&#39;, {          method: &#39;get&#39;,      }).then(function (response) {  //类似于 ES6中的promise      }).catch(function (err) {        // 出错了，等价于 then 的第二个参数，但这样更好用更直观      });</code></pre><ul><li>CORS的推荐链接：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li></ul><p>推荐链接里有详细的配置。</p><p>另外，如果面试官问：“CORS为什么支持跨域的通信？”</p><p>答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。</p><h3 id="4、Hash"><a href="#4、Hash" class="headerlink" title="4、Hash"></a>4、Hash</h3><p>url的<code>#</code>后面的内容就叫Hash。<strong>Hash的改变，页面不会刷新</strong>。这就是用 Hash 做跨域通信的基本原理。</p><p>补充：url的<code>?</code>后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。</p><p><strong>使用举例：</strong></p><p><strong>场景</strong>：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。</p><p>现在，我这个A页面想给B页面发消息，怎么操作呢？</p><p>（1）首先，在我的A页面中：</p><pre><code class="javascript">    //伪代码    var B = document.getElementsByTagName(&#39;iframe&#39;);    B.src = B.src + &#39;#&#39; + &#39;jsonString&#39;;  //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</code></pre><p>（2）然后，在B页面中：</p><pre><code class="javascript">    // B中的伪代码    window.onhashchange = function () {  //通过onhashchange方法监听，url中的 hash 是否发生变化        var data = window.location.hash;    };</code></pre><h3 id="5、postMessage-方法"><a href="#5、postMessage-方法" class="headerlink" title="5、postMessage()方法"></a>5、postMessage()方法</h3><blockquote><p>H5中新增的postMessage()方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。</p></blockquote><p><strong>场景</strong>：窗口 A (<code>http:A.com</code>)向跨域的窗口 B (<code>http:B.com</code>)发送信息。步骤如下。</p><p>（1）在A窗口中操作如下：向B窗口发送数据：</p><pre><code class="javascript">    // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息     Bwindow.postMessage(&#39;data&#39;, &#39;http://B.com&#39;); //这里强调的是B窗口里的window对象</code></pre><p>（2）在B窗口中操作如下：</p><pre><code class="javascript">    // 在窗口B中监听 message 事件    Awindow.addEventListener(&#39;message&#39;, function (event) {   //这里强调的是A窗口里的window对象        console.log(event.origin);  //获取 ：url。这里指：http://A.com        console.log(event.source);  //获取：A window对象        console.log(event.data);    //获取传过来的数据    }, false);</code></pre><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 05-02.面向对象：类的定义和继承的几种方式</title>
    <link href="/blog/20200307/"/>
    <url>/blog/20200307/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>类与实例：</p><ul><li><p>类的声明</p></li><li><p>生成实例</p></li></ul><p>类与继承：</p><ul><li><p>如何实现继承：继承的本质就是原型链</p></li><li><p>继承的几种方式</p></li></ul><h2 id="类的定义、实例化"><a href="#类的定义、实例化" class="headerlink" title="类的定义、实例化"></a>类的定义、实例化</h2><h3 id="类的定义-类的声明"><a href="#类的定义-类的声明" class="headerlink" title="类的定义/类的声明"></a>类的定义/类的声明</h3><p><strong>方式一</strong>：用构造函数模拟类（传统写法）</p><pre><code class="javascript">    function Animal1() {        this.name = &#39;smyhvae&#39;; //通过this，表明这是一个构造函数    }</code></pre><p><strong>方式二</strong>：用 class 声明（ES6的写法）</p><pre><code class="javascript">    class Animal2 {        constructor() {  //可以在构造函数里写属性            this.name = name;        }    }</code></pre><p>控制台的效果：</p><p><img src="http://img.smyhvae.com/20180307_0957.png" srcset="/img/loading.gif" alt=""></p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>类的实例化很简单，直接 new 出来即可。</p><pre><code class="javascript">    console.log(new Animal1(),new Animal2()); //实例化。如果括号里没有参数，则括号可以省略</code></pre><p><img src="http://img.smyhvae.com/20180307_1000.png" srcset="/img/loading.gif" alt=""></p><h2 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h2><p>继承的本质就是原型链。</p><p><strong>继承的方式有几种？每种形式的优缺点是</strong>？这些问题必问的。其实就是考察你对原型链的掌握程度。</p><h3 id="方式一：借助构造函数"><a href="#方式一：借助构造函数" class="headerlink" title="方式一：借助构造函数"></a>方式一：借助构造函数</h3><pre><code class="javascript">    function Parent1() {        this.name = &#39;parent1 的属性&#39;;    }    function Child1() {        Parent1.call(this);         //【重要】此处用 call 或 apply 都行：改变 this 的指向        this.type = &#39;child1 的属性&#39;;    }    console.log(new Child1);</code></pre><p>【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了<code>Parent1.call(this);</code>，意思是：<strong>让Parent的构造函数在child的构造函数中执行</strong>。发生的变化是：<strong>改变this的指向</strong>，parent的实例 –&gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。</p><p>打印结果：</p><p><img src="http://img.smyhvae.com/20180307_1015.png" srcset="/img/loading.gif" alt=""></p><p>上方结果表明：child先有了 parent 实例的属性（继承得以实现），再有了child 实例的属性。</p><p><strong>分析</strong>：</p><p>这种方式，虽然改变了 this 的指向，但是，<strong>Child1 无法继承 Parent1 的原型</strong>。也就是说，如果我给 Parent1 的原型增加一个方法：</p><pre><code class="javascript">    Parent1.prototype.say = function () {    };</code></pre><p>上面这个方法是无法被 Child1 继承的。如下：</p><p><img src="http://img.smyhvae.com/20180307_1030.png" srcset="/img/loading.gif" alt=""></p><h3 id="方法二：通过原型链实现继承"><a href="#方法二：通过原型链实现继承" class="headerlink" title="方法二：通过原型链实现继承"></a>方法二：通过原型链实现继承</h3><pre><code class="javascript">    /*    通过原型链实现继承     */    function Parent() {        this.name = &#39;Parent 的属性&#39;;    }    function Child() {        this.type = &#39;Child 的属性&#39;;    }    Child.prototype = new Parent(); //【重要】    console.log(new Child());</code></pre><p>打印结果：</p><p><img src="http://img.smyhvae.com/20180307_1109.png" srcset="/img/loading.gif" alt=""></p><p>【重要】上方代码中，最重要的那行：每个函数都有<code>prototype</code>属性，于是，构造函数也有这个属性，这个属性是一个对象。现在，<strong>我们把<code>Parent</code>的实例赋值给了<code>Child</code>的<code>prototye</code></strong>，从而实现<strong>继承</strong>。此时，<code>Child</code>构造函数、<code>Parent</code>的实例、<code>Child</code>的实例构成一个三角关系。于是：</p><ul><li><code>new Child.__proto__ === new Parent()</code>的结果为true</li></ul><p><strong>分析：</strong></p><p>这种继承方式，<strong>Child 可以继承 Parent 的原型</strong>，但有个缺点：</p><p>缺点是：<strong>如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变</strong>。</p><p>如下：</p><p><img src="http://img.smyhvae.com/20180307_1123.png" srcset="/img/loading.gif" alt=""></p><p>上面的代码中， child1修改了arr属性，却发现，child2的arr属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。</p><p>造成这种缺点的原因是：child1和child2共用原型。即：<code>chi1d1.__proto__ === child2__proto__</code>是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。</p><h2 id="方式三：组合的方式：构造函数-原型链"><a href="#方式三：组合的方式：构造函数-原型链" class="headerlink" title="方式三：组合的方式：构造函数 + 原型链"></a>方式三：组合的方式：构造函数 + 原型链</h2><p>就是把上面的两种方式组合起来：</p><pre><code class="javascript">    /*    组合方式实现继承：构造函数、原型链     */    function Parent3() {        this.name = &#39;Parent 的属性&#39;;        this.arr = [1, 2, 3];    }    function Child3() {        Parent3.call(this); //【重要1】执行 parent方法        this.type = &#39;Child 的属性&#39;;    }    Child3.prototype = new Parent3(); //【重要2】第二次执行parent方法    var child = new Child3();</code></pre><p>这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。</p><p>这种方式的缺点是：让父亲Parent的构造方法执行了两次。</p><pre><code class="javascript"></code></pre><p>ES6中的继承方式，一带而过即可，重点是要掌握ES5中的继承。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 05-01.创建对象和原型链</title>
    <link href="/blog/20200306/"/>
    <url>/blog/20200306/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><ul><li><p>封装</p></li><li><p>继承</p></li><li><p>多态</p></li></ul><h3 id="原型链的知识"><a href="#原型链的知识" class="headerlink" title="原型链的知识"></a>原型链的知识</h3><p>原型链是面向对象的基础，是非常重要的部分。有以下几种知识：</p><ul><li><p>创建对象有几种方法</p></li><li><p>原型、构造函数、实例、原型链</p></li><li><p><code>instanceof</code>的原理</p></li><li><p>new 运算符</p></li></ul><h2 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h2><h3 id="方式一：字面量"><a href="#方式一：字面量" class="headerlink" title="方式一：字面量"></a>方式一：字面量</h3><pre><code class="javascript">    var obj11 = {name: &#39;qianguyihao&#39;};    var obj12 = new Object(name: &#39;qianguyihao&#39;); //内置对象（内置的构造函数）</code></pre><p>上面的两种写法，效果是一样的。因为，第一种写法，<code>obj11</code>会指向<code>Object</code>。</p><ul><li><p>第一种写法是：字面量的方式。</p></li><li><p>第二种写法是：内置的构造函数</p></li></ul><h3 id="方式二：通过构造函数"><a href="#方式二：通过构造函数" class="headerlink" title="方式二：通过构造函数"></a>方式二：通过构造函数</h3><pre><code class="javascript">    var M = function (name) {        this.name = name;    }    var obj3 = new M(&#39;smyhvae&#39;);</code></pre><h3 id="方法三：Object-create"><a href="#方法三：Object-create" class="headerlink" title="方法三：Object.create"></a>方法三：Object.create</h3><pre><code class="javascript">    var p = {name:&#39;smyhvae&#39;};    var obj3 = Object.create(p);  //此方法创建的对象，是用原型链连接的</code></pre><p>第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的原型（name是p原型里的属性），构造函数是<code>Objecet</code> 。</p><p><img src="http://img.smyhvae.com/20180306_1633.png" srcset="/img/loading.gif" alt=""></p><h2 id="原型、构造函数、实例，以及原型链"><a href="#原型、构造函数、实例，以及原型链" class="headerlink" title="原型、构造函数、实例，以及原型链"></a>原型、构造函数、实例，以及原型链</h2><p><img src="http://img.smyhvae.com/20180306_1540.png" srcset="/img/loading.gif" alt=""></p><p>PS：任何一个函数，如果在前面加了new，那就是构造函数。</p><h3 id="原型、构造函数、实例三者之间的关系"><a href="#原型、构造函数、实例三者之间的关系" class="headerlink" title="原型、构造函数、实例三者之间的关系"></a>原型、构造函数、实例三者之间的关系</h3><p><img src="http://img.smyhvae.com/20180306_2107.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>1、构造函数通过 new 生成实例</p></li><li><p>2、构造函数也是函数，构造函数的<code>prototype</code>指向原型。（所有的函数有<code>prototype</code>属性，但实例没有 <code>prototype</code>属性）</p></li><li><p>3、原型对象中有 constructor，指向该原型的构造函数。</p></li></ul><p>上面的三行，代码演示：</p><pre><code>    var Foo = function (name) {        this.name = name;    }    var foo = new Foo(&#39;smyhvae&#39;);</code></pre><p>上面的代码中，<code>Foo.prototype.constructor === Foo</code>的结果是<code>true</code>：</p><p><img src="http://img.smyhvae.com/20180306_2120.png" srcset="/img/loading.gif" alt=""></p><ul><li>4、实例的<code>__proto__</code>指向原型。也就是说，<code>foo.__proto__ === Foo.prototype</code>。</li></ul><p>声明：所有的<strong>引用类型</strong>（数组、对象、函数）都有<code>__proto__</code>这个属性。</p><p><code>Foo.__proto__ === Function.prototype</code>的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>原型链的基本原理</strong>：任何一个<strong>实例</strong>，通过原型链，找到它上面的<strong>原型</strong>，该原型对象中的方法和属性，可以被所有的原型实例共享。</p><p>Object是原型链的顶端。</p><p>原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：</p><pre><code>    //给Foo的原型添加 say 函数    Foo.prototype.say = function () {        console.log(&#39;&#39;);    }</code></pre><p><strong>原型链的关键</strong>：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。</p><h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a><code>instanceof</code>的原理</h3><p><img src="http://img.smyhvae.com/20180306_2209.png" srcset="/img/loading.gif" alt=""></p><p><code>instanceof</code>的<strong>作用</strong>：用于判断<strong>实例</strong>属于哪个<strong>构造函数</strong>。</p><p><code>instanceof</code>的<strong>原理</strong>：判断实例对象的<code>__proto__</code>属性，和构造函数的<code>prototype</code>属性，是否为同一个引用（是否指向同一个地址）。</p><p><strong>注意1</strong>：虽然说，实例是由构造函数 new 出来的，但是实例的<code>__proto__</code>属性引用的是构造函数的<code>prototype</code>。也就是说，实例的<code>__proto__</code>属性与构造函数本身无关。</p><p><strong>注意2</strong>：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找<code>__proto__</code>属性。这条链上如果能找到， instanceof 的返回结果也是 true。</p><p>比如说：</p><ul><li><p><code>foo instance of Foo</code>的结果为true，因为<code>foo.__proto__ === Foo.prototype</code>为true。</p></li><li><p><strong><code>foo instance of Objecet</code>的结果也为true</strong>，因为<code>Foo.prototype.__proto__ === Object.prototype</code>为true。</p></li></ul><p>但我们不能轻易的说：<code>foo 一定是 由Object创建的实例</code>。这句话是错误的。我们来看下一个问题就明白了。</p><h3 id="分析一个问题"><a href="#分析一个问题" class="headerlink" title="分析一个问题"></a>分析一个问题</h3><p><strong>问题：</strong>已知A继承了B，B继承了C。怎么判断 a 是由A<strong>直接生成</strong>的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？</p><p>分析：这就要用到原型的<code>constructor</code>属性了。</p><ul><li><code>foo.__proto__.constructor === Foo</code>的结果为true，但是 <code>foo.__proto__.constructor === Object</code>的结果为false。</li></ul><p>所以，用 consturctor判断就比用 instanceof判断，更为严谨。</p><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><p>当new Foo()时发生了什么：</p><p>（1）创建一个<strong>新的空对象实例</strong>。</p><p>（2）将此空对象的隐式原型指向其构造函数的显示原型。</p><p>（3）执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。</p><p>（4）如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。</p><p>参考《JS高程》6.2.2</p><h2 id="类继承和原型继承的区别"><a href="#类继承和原型继承的区别" class="headerlink" title="类继承和原型继承的区别"></a>类继承和原型继承的区别</h2><pre><code class="javascript"></code></pre><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 04-HTTP协议</title>
    <link href="/blog/20200305/"/>
    <url>/blog/20200305/</url>
    
    <content type="html"><![CDATA[<p>一面中，如果有笔试，考HTTP协议的可能性较大。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一面要讲的内容：</p><ul><li><p>HTTP协议的主要特点</p></li><li><p>HTTP报文的组成部分</p></li><li><p>HTTP方法</p></li><li><p>get 和 post的区别</p></li><li><p>HTTP状态码</p></li><li><p>什么是持久连接</p></li><li><p>什么是管线化</p></li></ul><p>二面要讲的内容；</p><ul><li><p>缓存</p></li><li><p>CSRF攻击</p></li></ul><h2 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h2><ul><li><p>简单快速</p></li><li><p>灵活</p></li><li><p><strong>无连接</strong></p></li><li><p><strong>无状态</strong></p></li></ul><p>通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：<strong>无连接、无状态</strong>。</p><p>我们分别来解释一下。</p><h3 id="简单快速"><a href="#简单快速" class="headerlink" title="简单快速"></a>简单快速</h3><p><strong>简单</strong>：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。</p><h3 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h3><p>http协议的头部有一个<code>数据类型</code>，通过http协议，就可以完成不同数据类型的传输。</p><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>连接一次，就会断开，不会继续保持连接。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，<strong>服务器端并没有记住之前的状态</strong>，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。</p><p>有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。</p><h2 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h2><p><img src="http://img.smyhvae.com/20180306_1400.png" srcset="/img/loading.gif" alt=""></p><p>在回答此问题时，我们要按照顺序回答：</p><ul><li><p>先回答的是，http报文包括：<strong>请求报文</strong>和<strong>响应报文</strong>。</p></li><li><p>再回答的是，每个报文包含什么部分。</p></li><li><p>最后回答，每个部分的内容是什么</p></li></ul><h3 id="请求报文包括："><a href="#请求报文包括：" class="headerlink" title="请求报文包括："></a>请求报文包括：</h3><p><img src="http://img.smyhvae.com/20180228_1505.jpg" srcset="/img/loading.gif" alt=""></p><ul><li><p>请求行：包括请求方法、请求的url、http协议及版本。</p></li><li><p>请求头：一大堆的键值对。</p></li><li><p><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</p></li><li><p>请求体：数据部分。</p></li></ul><h3 id="响应报文包括："><a href="#响应报文包括：" class="headerlink" title="响应报文包括："></a>响应报文包括：</h3><p><img src="http://img.smyhvae.com/20180228_1510.jpg" srcset="/img/loading.gif" alt=""></p><ul><li><p>状态行：http协议及版本、状态码及状态描述。</p></li><li><p>响应头</p></li><li><p>空行</p></li><li><p>响应体</p></li></ul><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>包括：</p><ul><li><p>GET：获取资源</p></li><li><p>POST：传输资源</p></li><li><p>put：更新资源</p></li><li><p>DELETE：删除资源</p></li><li><p>HEAD：获得报文首部</p></li></ul><p>HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p><p>get 和 post 比较常见。</p><p>put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</p><p>head 可能偶尔用的到。</p><h2 id="get-和-post的区别"><a href="#get-和-post的区别" class="headerlink" title="get 和 post的区别"></a>get 和 post的区别</h2><p><img src="http://img.smyhvae.com/20180306_1415.png" srcset="/img/loading.gif" alt=""></p><p>区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。</p><p>有一点要强调，<strong>get是相对不隐私的，而post是相对隐私的</strong>。</p><p>我们大概要记住以下几点：</p><p>1、浏览器在回退时，get<strong>不会重新请求</strong>，但是post会重新请求。【重要】</p><p>2、get请求会被浏览器<strong>主动缓存</strong>，而post不会。【重要】</p><p>3、get请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。</p><p>4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有注意。</p><p>5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。</p><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>http状态码分类：</p><p><img src="http://img.smyhvae.com/20180306_1430.png" srcset="/img/loading.gif" alt=""></p><p>常见的http状态码：</p><p><img src="http://img.smyhvae.com/20180306_1431.png" srcset="/img/loading.gif" alt=""></p><p>部分解释：</p><ul><li>206的应用：<code>range</code>指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。</li></ul><ul><li><p>301：重定向（永久）。</p></li><li><p>302：重定向（临时）。</p></li><li><p>304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。</p></li></ul><p><img src="http://img.smyhvae.com/20180306_1440.png" srcset="/img/loading.gif" alt=""></p><p>400和401用的不多。403指的是请求被拒绝。404指的是资源不存在。</p><h2 id="持久链接-http长连接"><a href="#持久链接-http长连接" class="headerlink" title="持久链接/http长连接"></a>持久链接/http长连接</h2><blockquote><p>如果你能答出持久链接，这是面试官很想知道的一个点。</p></blockquote><ul><li><strong>轮询</strong>：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</li></ul><ul><li><strong>长连接</strong>：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</li></ul><p>注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对<strong>每个请求仍然要单独发 header</strong>，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><h2 id="长连接中的管线化"><a href="#长连接中的管线化" class="headerlink" title="长连接中的管线化"></a>长连接中的管线化</h2><blockquote><p>如果能答出<strong>管线化</strong>，则属于加分项。</p></blockquote><h3 id="管线化的原理"><a href="#管线化的原理" class="headerlink" title="管线化的原理"></a>管线化的原理</h3><p>长连接时，<strong>默认</strong>的请求这样的：</p><pre><code>    请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3</code></pre><p>长连接中的管线化，请求是这样的：</p><pre><code>    请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre><p>管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。</p><h3 id="管线化的注意事项"><a href="#管线化的注意事项" class="headerlink" title="管线化的注意事项"></a>管线化的注意事项</h3><p>面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 03-DOM事件的总结</title>
    <link href="/blog/20200304/"/>
    <url>/blog/20200304/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要学习事件的基础内容，请看先本人之前的基础文章：</p><ul><li><p>《04-JavaScript基础/27-事件对象Event》</p></li><li><p>《04-JavaScript基础/28-事件捕获和事件冒泡》</p></li><li><p>《04-JavaScript基础/29-事件委托》</p></li></ul><p>知识难度不大，只是大家需要系统地学习。</p><p><strong>知识点主要包括以下几个方面：</strong></p><ul><li>基本概念：DOM事件的级别</li></ul><p>面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ….”。</p><ul><li>DOM事件模型、DOM事件流</li></ul><p>面试官如果问你“<strong>DOM事件模型</strong>”，你不一定知道怎么回事。其实说的就是<strong>捕获和冒泡</strong>。</p><p><strong>DOM事件流</strong>，指的是事件传递的<strong>三个阶段</strong>。</p><ul><li>描述DOM事件捕获的具体流程</li></ul><p>讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。</p><p>能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。</p><ul><li>Event对象的常见应用（Event的常用api方法）</li></ul><p>DOM事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。</p><ul><li>自定义事件（非常重要）</li></ul><p>一般人可以讲出事件和注册事件，但是如果让你讲<strong>自定义事件</strong>，能知道的人，就更少了。</p><ul><li>事件委托</li></ul><p>业务中经常用到。</p><p>下面分别讲解。</p><h2 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h2><p>DOM事件的级别，准确来说，是<strong>DOM标准</strong>定义的级别。包括：</p><p><strong>DOM0的写法：</strong></p><pre><code class="javascript">    element.onclick = function () {    }</code></pre><p>上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。</p><p><strong>DOM2的写法：</strong></p><pre><code class="javascript">    element.addEventListener(&#39;click&#39;, function () {    }, false);</code></pre><p>【重要】上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。如果不写，则默认为false。</p><p><strong>DOM3的写法：</strong></p><pre><code class="javascript">    element.addEventListener(&#39;keyup&#39;, function () {    }, false);</code></pre><p>DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。</p><p>PS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。</p><p><strong>总结</strong>：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。</p><h2 id="DOM事件模型、DOM事件流"><a href="#DOM事件模型、DOM事件流" class="headerlink" title="DOM事件模型、DOM事件流"></a>DOM事件模型、DOM事件流</h2><h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p>DOM事件模型讲的就是<strong>捕获和冒泡</strong>，一般人都能回答出来。</p><ul><li><p>捕获：从上往下。</p></li><li><p>冒泡：从下（目标元素）往上。</p></li></ul><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p><p>类似于Android里面的事件传递。</p><p>完整的事件流，分三个阶段：</p><ul><li><p>（1）捕获：从 window 对象传到 目标元素。</p></li><li><p>（2）目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</p></li><li><p>（3）冒泡：从<strong>目标元素</strong>传到 Window 对象。</p></li></ul><p><img src="http://img.smyhvae.com/20180306_1058.png" srcset="/img/loading.gif" alt=""></p><p><img src="http://img.smyhvae.com/20180204_1218.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h2><blockquote><p>很少有人能说完整。</p></blockquote><h3 id="捕获的流程"><a href="#捕获的流程" class="headerlink" title="捕获的流程"></a>捕获的流程</h3><p><img src="http://img.smyhvae.com/20180306_1103.png" srcset="/img/loading.gif" alt=""></p><p><strong>说明</strong>：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。</p><p>PS1：第一个接收到事件的对象是 <strong>window</strong>（有人会说body，有人会说html，这都是错误的）。</p><p>PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。</p><p>代码如下：</p><pre><code class="javascript">    window.addEventListener(&quot;click&quot;, function () {        alert(&quot;捕获 window&quot;);    }, true);    document.addEventListener(&quot;click&quot;, function () {        alert(&quot;捕获 document&quot;);    }, true);    document.documentElement.addEventListener(&quot;click&quot;, function () {        alert(&quot;捕获 html&quot;);    }, true);    document.body.addEventListener(&quot;click&quot;, function () {        alert(&quot;捕获 body&quot;);    }, true);    fatherBox.addEventListener(&quot;click&quot;, function () {        alert(&quot;捕获 father&quot;);    }, true);    childBox.addEventListener(&quot;click&quot;, function () {        alert(&quot;捕获 child&quot;);    }, true);</code></pre><p><strong>补充一个知识点：</strong></p><p>在 js中：</p><ul><li><p>如果想获取 <code>body</code> 节点，方法是：<code>document.body</code>；</p></li><li><p>但是，如果想获取 <code>html</code>节点，方法是<code>document.documentElement</code>。</p></li></ul><h3 id="冒泡的流程"><a href="#冒泡的流程" class="headerlink" title="冒泡的流程"></a>冒泡的流程</h3><p>与捕获的流程相反</p><h2 id="Event对象的常见-api-方法"><a href="#Event对象的常见-api-方法" class="headerlink" title="Event对象的常见 api 方法"></a>Event对象的常见 api 方法</h2><p>用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code class="javascript">    event.preventDefault();</code></pre><p>解释：阻止默认事件。</p><p>比如，已知<code>&lt;a&gt;</code>标签绑定了click事件，此时，如果给<code>&lt;a&gt;</code>设置了这个方法，就阻止了链接的默认跳转。</p><h3 id="方法二：阻止冒泡"><a href="#方法二：阻止冒泡" class="headerlink" title="方法二：阻止冒泡"></a>方法二：阻止冒泡</h3><p>这个在业务中很常见。</p><p>有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。</p><p>w3c的方法：（火狐、谷歌、IE11）</p><pre><code class="javascript">    event.stopPropagation();</code></pre><p>IE10以下则是：</p><pre><code class="javascript">    event.cancelBubble = true;</code></pre><p>兼容代码如下：</p><pre><code class="javascript">   box3.onclick = function (event) {        alert(&quot;child&quot;);        //阻止冒泡        event = event || window.event;        if (event &amp;&amp; event.stopPropagation) {            event.stopPropagation();        } else {            event.cancelBubble = true;        }    }</code></pre><p>上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。</p><h3 id="方法三：设置事件优先级"><a href="#方法三：设置事件优先级" class="headerlink" title="方法三：设置事件优先级"></a>方法三：设置事件优先级</h3><pre><code class="javascript">    event.stopImmediatePropagation();</code></pre><p>这个方法比较长，一般人没听说过。解释如下：</p><p>比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到<code>stopImmediatePropagation</code>方法了。做法是：在事件A的响应函数中加入这句话。</p><p>大家要记住 event 有这个方法。</p><h3 id="属性4、属性5（事件委托中用到）"><a href="#属性4、属性5（事件委托中用到）" class="headerlink" title="属性4、属性5（事件委托中用到）"></a>属性4、属性5（事件委托中用到）</h3><pre><code class="javascript">    event.currentTarget   //当前所绑定的事件对象。在事件委托中，指的是【父元素】。    event.target  //当前被点击的元素。在事件委托中，指的是【子元素】。</code></pre><p>上面这两个属性，在事件委托中经常用到。</p><p><strong>总结</strong>：上面这几项，非常重要，但是容易弄混淆。</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>自定义事件的代码如下：</p><pre><code class="javascript">    var myEvent = new Event(&#39;clickTest&#39;);    element.addEventListener(&#39;clickTest&#39;, function () {        console.log(&#39;smyhvae&#39;);    });    //元素注册事件    element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</code></pre><p>上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：</p><pre><code class="javascript">    var myEvent = new Event(&#39;clickTest&#39;);    element.addEventListener(&#39;clickTest&#39;, function () {        console.log(&#39;smyhvae&#39;);    });    setTimeout(function () {        element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest    }, 1000);</code></pre><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 02-CSS盒模型及BFC</title>
    <link href="/blog/20200303/"/>
    <url>/blog/20200303/</url>
    
    <content type="html"><![CDATA[<h2 id="题目：谈一谈你对CSS盒模型的认识"><a href="#题目：谈一谈你对CSS盒模型的认识" class="headerlink" title="题目：谈一谈你对CSS盒模型的认识"></a>题目：谈一谈你对CSS盒模型的认识</h2><p>专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面：</p><p>（1）基本概念：content、padding、margin。</p><p>（2）标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人。</p><p>（3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</p><p>（4）JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</p><p>（5）实例题：根据盒模型解释<strong>边距重叠</strong>。</p><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p><p>（6）BFC（边距重叠解决方案）或IFC。</p><p>如果能回答第五条，就会引出第六条。BFC是面试频率较高的。</p><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论。</p><p>接下来，我们把上面的六条，依次讲解。</p><h2 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h2><p>标准盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg" srcset="/img/loading.gif" alt=""></p><p>IE盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg" srcset="/img/loading.gif" alt=""></p><p>上图显示：</p><p>在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p>CSS盒模型和IE盒模型的区别：</p><ul><li><p>在 <font color="#0000FF"><strong>标准盒子模型</strong></font>中，<font color="#0000FF"><strong>width 和 height 指的是内容区域</strong></font>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p></li><li><p><font color="#0000FF"><strong>IE盒子模型</strong></font>中，<font color="#0000FF"><strong>width 和 height 指的是内容区域+border+padding</strong></font>的宽度和高度。</p></li></ul><h2 id="CSS如何设置这两种模型"><a href="#CSS如何设置这两种模型" class="headerlink" title="CSS如何设置这两种模型"></a>CSS如何设置这两种模型</h2><p>代码如下：</p><pre><code class="javascript">    /* 设置当前盒子为 标准盒模型（默认） */    box-sizing: content-box;    /* 设置当前盒子为 IE盒模型 */    box-sizing: border-box;</code></pre><p>备注：盒子默认为标准盒模型。</p><h2 id="JS如何设置、获取盒模型对应的宽和高"><a href="#JS如何设置、获取盒模型对应的宽和高" class="headerlink" title="JS如何设置、获取盒模型对应的宽和高"></a>JS如何设置、获取盒模型对应的宽和高</h2><h3 id="方式一：通过DOM节点的-style-样式获取"><a href="#方式一：通过DOM节点的-style-样式获取" class="headerlink" title="方式一：通过DOM节点的 style 样式获取"></a>方式一：通过DOM节点的 style 样式获取</h3><pre><code class="javascript">    element.style.width/height;</code></pre><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p><p>这种方式有局限性，但应该了解。</p><h3 id="方式二（通用型）"><a href="#方式二（通用型）" class="headerlink" title="方式二（通用型）"></a>方式二（通用型）</h3><pre><code class="javascript">    window.getComputedStyle(element).width/height;</code></pre><p>方式二能兼容 Chrome、火狐。是通用型方式。</p><h3 id="方式三（IE独有的）"><a href="#方式三（IE独有的）" class="headerlink" title="方式三（IE独有的）"></a>方式三（IE独有的）</h3><pre><code class="javascript">    element.currentStyle.width/height;</code></pre><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><pre><code class="javascript">    element.getBoundingClientRect().width/height;</code></pre><p>此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。</p><p>此 api 可以拿到四个属性：left、top、width、height。</p><p><strong>总结：</strong></p><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p><h2 id="margin塌陷-margin重叠"><a href="#margin塌陷-margin重叠" class="headerlink" title="margin塌陷/margin重叠"></a>margin塌陷/margin重叠</h2><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。</p><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。</p><p>我们来看几个例子。</p><h3 id="兄弟元素之间"><a href="#兄弟元素之间" class="headerlink" title="兄弟元素之间"></a>兄弟元素之间</h3><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png" srcset="/img/loading.gif" alt=""></p><h3 id="子元素和父元素之间"><a href="#子元素和父元素之间" class="headerlink" title="子元素和父元素之间"></a>子元素和父元素之间</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        * {            margin: 0;            padding: 0;        }        .father {            background: green;        }        /* 给儿子设置margin-top为10像素 */        .son {            height: 100px;            margin-top: 10px;            background: red;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。</p><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png" srcset="/img/loading.gif" alt=""></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png" srcset="/img/loading.gif" alt=""></p><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p><h3 id="善于使用父亲的padding，而不是儿子的margin"><a href="#善于使用父亲的padding，而不是儿子的margin" class="headerlink" title="善于使用父亲的padding，而不是儿子的margin"></a>善于使用父亲的padding，而不是儿子的margin</h3><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p）</p><pre><code>    &lt;div&gt;        &lt;p&gt;&lt;/p&gt;    &lt;/div&gt;</code></pre><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p><p><img src="http://img.smyhvae.com/20170806_1537.png" srcset="/img/loading.gif" alt=""></p><p>此时我们给父亲div加一个border属性，就正常了：</p><p><img src="http://img.smyhvae.com/20170806_1544.png" srcset="/img/loading.gif" alt=""></p><p>如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。</p><h2 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h2><h3 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h3><p>BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。</p><p>另外还有个概念叫IFC。不过，BFC问得更多。</p><h3 id="BFC-的原理-BFC的布局规则【非常重要】"><a href="#BFC-的原理-BFC的布局规则【非常重要】" class="headerlink" title="BFC 的原理/BFC的布局规则【非常重要】"></a>BFC 的原理/BFC的布局规则【非常重要】</h3><p>BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：</p><ul><li><p>（1）BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</p></li><li><p>（2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</p></li><li><p>（3）<strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</p></li><li><p>（4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</p></li></ul><h3 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h3><p>有以下几种方法：</p><ul><li><p>方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】</p></li><li><p>方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。</p></li><li><p>方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个BFC。</p></li><li><p>方法4：display为inline-block, table-cell, table-caption, flex, inline-flex</p></li></ul><p>参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000006740129" target="_blank" rel="noopener">BFC原理详解</a></li></ul><ul><li><a href="https://www.jianshu.com/p/bf927bc1bed4" target="_blank" rel="noopener">BFC详解</a></li></ul><ul><li><a href="https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener">前端精选文摘：BFC 神奇背后的原理</a></li></ul><p>下面来看几个例子，看看如何生成BFC。</p><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><p><strong>举例1：</strong>解决 margin 重叠</p><p>当父元素和子元素发生 margin 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p><p>比如说，针对下面这样一个 div 结构：</p><pre><code class="html">&lt;div class=&quot;father&quot;&gt;    &lt;p class=&quot;son&quot;&gt;    &lt;/p&gt;&lt;/div&gt;</code></pre><p>上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了：</p><pre><code class="html">&lt;div class=&quot;father&quot;&gt;    &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt;    &lt;/p&gt;&lt;/div&gt;</code></pre><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .father-layout {            background: pink;        }        .father-layout .left {            float: left;            width: 100px;            height: 100px;            background: green;        }        .father-layout .right {            height: 150px;  /*右侧标准流里的元素，比左侧浮动的元素要高*/            background: red;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt;    &lt;div class=&quot;left&quot;&gt;        左侧，生命壹号    &lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，    &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png" srcset="/img/loading.gif" alt=""></p><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><pre><code class="html">    &lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt;        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，    &lt;/div&gt;</code></pre><p><img src="http://img.smyhvae.com/20180306_0827.png" srcset="/img/loading.gif" alt=""></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .father {            background: pink;        }        .son {            float: left;            background: green;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;        生命壹号    &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png" srcset="/img/loading.gif" alt=""></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0845.png" srcset="/img/loading.gif" alt=""></p><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong>。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 01-页面布局</title>
    <link href="/blog/20200302/"/>
    <url>/blog/20200302/</url>
    
    <content type="html"><![CDATA[<h2 id="前端面试（前言）"><a href="#前端面试（前言）" class="headerlink" title="前端面试（前言）"></a>前端面试（前言）</h2><h3 id="面试基础"><a href="#面试基础" class="headerlink" title="面试基础"></a>面试基础</h3><ul><li><p>页面布局</p></li><li><p>CSS盒模型：是CSS的基石。</p></li><li><p>DOM事件</p></li><li><p>HTTP协议</p></li><li><p>面向对象</p></li><li><p>原型链：能说出原型链的始末</p></li></ul><h3 id="面试进阶"><a href="#面试进阶" class="headerlink" title="面试进阶"></a>面试进阶</h3><ul><li><p>通信：普通的通信、跨域通信</p></li><li><p>安全：CSRF、XSS。</p></li><li><p>算法</p></li></ul><h3 id="回答问题时要注意的"><a href="#回答问题时要注意的" class="headerlink" title="回答问题时要注意的"></a>回答问题时要注意的</h3><p>（1）题干的要求真的是字面要求的这么简单吗？</p><p>（2）答案怎么写，技巧在哪里</p><p>（3）如果想证明我的实力，应该有几种答案？</p><p>本文来讲一下页面布局。</p><h2 id="题目：页面布局"><a href="#题目：页面布局" class="headerlink" title="题目：页面布局"></a>题目：页面布局</h2><p>问题：假设容器的高度默认100px，请写出<strong>三栏布局</strong>，其中左栏、右栏的宽度各为300px，中间的宽度自适应。</p><p><img src="http://img.smyhvae.com/20180305_1520.png" srcset="/img/loading.gif" alt=""></p><p>分析：</p><p>初学者想到的答案有两种：</p><ul><li><p>方法1：浮动</p></li><li><p>方法2：绝对定位。</p></li></ul><p>但要求你能至少写出三四种方法，才算及格。剩下的方法如下：</p><ul><li><p>方法3：flexbox。移动开发里经常用到。</p></li><li><p>方法4：表格布局 table。虽然已经淘汰了，但也应该了解。</p></li><li><p>方法5：网格布局 grid。</p></li></ul><p>下面分别讲解。</p><h3 id="方法1-和方法2"><a href="#方法1-和方法2" class="headerlink" title="方法1 和方法2"></a>方法1 和方法2</h3><p><strong>方法1、浮动：</strong></p><p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p><p><strong>方法2、绝对定位：</strong></p><p>左侧设置为绝对定位， left：0px。右侧设置为绝对定位， right：0px。中间设置为绝对定位，left 和right 都为300px，即可。中间的宽度会自适应。</p><p>使用<code>article</code>标签作为容器，包裹左、中、右三个部分。</p><p>方法1 和方法2 的代码如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        html * {            padding: 0px;            margin: 0px;        }        .layout {            margin-bottom: 150px;        }        .layout article div { /*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/            height: 100px;        }        /* 方法一 start */        .layout.float .left {            float: left;            width: 300px;            background: red;        }        .layout.float .right {            float: right;            width: 300px;            background: blue;        }        .layout.float .center {            background: green;        }        /* 方法一 end */        /* 方法二 start */        .layout.absolute .left-center-right {            position: relative;        }        .layout.absolute .left {            position: absolute;            left: 0;            width: 300px;            background: red;        }        /* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */        .layout.absolute .center {            position: absolute;            left: 300px;            right: 300px;            background: green;        }        .layout.absolute .right {            position: absolute;            right: 0;            width: 300px;            background: blue;        }        /* 方法二 end */    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 方法一：浮动 start --&gt;    &lt;!-- 输入 section.layout.float，即可生成  --&gt;    &lt;section class=&quot;layout float&quot;&gt;        &lt;!-- 用  article 标签包裹左、中、右三个部分 --&gt;        &lt;article class=&quot;left-right-center&quot;&gt;            &lt;!-- 输入 div.left+div.right+div.center，即可生成 --&gt;            &lt;div class=&quot;left&quot;&gt;                我是 left            &lt;/div&gt;            &lt;div class=&quot;right&quot;&gt;                我是 right            &lt;/div&gt;            &lt;div class=&quot;center&quot;&gt;                浮动解决方案                我是 center            &lt;/div&gt;        &lt;/article&gt;    &lt;/section&gt;    &lt;!-- 方法一：浮动 end --&gt;    &lt;section class=&quot;layout absolute&quot;&gt;        &lt;article class=&quot;left-center-right&quot;&gt;            &lt;div class=&quot;left&quot;&gt;                我是 left            &lt;/div&gt;            &lt;div class=&quot;right&quot;&gt;                我是 right            &lt;/div&gt;            &lt;div class=&quot;center&quot;&gt;                &lt;h1&gt;绝对定位解决方案&lt;/h1&gt;                我是 center            &lt;/div&gt;        &lt;/article&gt;    &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>注意上方代码中， className 定义和使用，非常规范。</p><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180305_1640.gif" srcset="/img/loading.gif" alt=""></p><h3 id="方法3、flexbox布局"><a href="#方法3、flexbox布局" class="headerlink" title="方法3、flexbox布局"></a>方法3、flexbox布局</h3><p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        html * {            padding: 0;            margin: 0;        }        .layout article div {            height: 100px;        }        .left-center-right {            display: flex;        }        .layout.flex .left {            width: 300px;            background: red;        }        .layout.flex .center {            flex: 1;            background: green;        }        .layout.flex .right {            width: 300px;            background: blue;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;section class=&quot;layout flex&quot;&gt;        &lt;article class=&quot;left-center-right&quot;&gt;            &lt;div class=&quot;left&quot;&gt;                我是 left            &lt;/div&gt;            &lt;div class=&quot;center&quot;&gt;                &lt;h1&gt;flex布局解决方案&lt;/h1&gt;                我是 center            &lt;/div&gt;            &lt;div class=&quot;right&quot;&gt;                我是 right            &lt;/div&gt;        &lt;/article&gt;    &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180305_1700.gif" srcset="/img/loading.gif" alt=""></p><h3 id="方法4、表格布局-table"><a href="#方法4、表格布局-table" class="headerlink" title="方法4、表格布局 table"></a>方法4、表格布局 table</h3><p>设置整个容器的宽度为100%，设置三个部分均为表格，然后左边的单元格为 300px，右边的单元格为 300px，即可。中间的单元格会自适应。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        html * {            padding: 0;            margin: 0;        }        .layout.table div {            height: 100px;        }        /* 重要：设置容器为表格布局，宽度为100% */        .layout.table .left-center-right {            width: 100%;            display: table;            height: 100px;        }        .layout.table .left-center-right div {            display: table-cell; /* 重要：设置三个模块为表格里的单元*/        }        .layout.table .left {            width: 300px;            background: red;        }        .layout.table .center {            background: green;        }        .layout.table .right {            width: 300px;            background: blue;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;section class=&quot;layout table&quot;&gt;        &lt;article class=&quot;left-center-right&quot;&gt;            &lt;div class=&quot;left&quot;&gt;                我是 left            &lt;/div&gt;            &lt;div class=&quot;center&quot;&gt;                &lt;h1&gt;表格布局解决方案&lt;/h1&gt;                我是 center            &lt;/div&gt;            &lt;div class=&quot;right&quot;&gt;                我是 right            &lt;/div&gt;        &lt;/article&gt;    &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="http://img.smyhvae.com/20180305_1855.gif" srcset="/img/loading.gif" alt=""></p><h3 id="方法5、网格布局-grid"><a href="#方法5、网格布局-grid" class="headerlink" title="方法5、网格布局 grid"></a>方法5、网格布局 grid</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        html * {            padding: 0;            margin: 0;        }        /* 重要：设置容器为网格布局，宽度为100% */        .layout.grid .left-center-right {            display: grid;            width: 100%;            grid-template-rows: 100px;            grid-template-columns: 300px auto 300px;  /* 重要：设置网格为三列，并设置每列的宽度。即可。*/        }        .layout.grid .left {            background: red;        }        .layout.grid .center {            background: green;        }        .layout.grid .right {            background: blue;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;section class=&quot;layout grid&quot;&gt;        &lt;article class=&quot;left-center-right&quot;&gt;            &lt;div class=&quot;left&quot;&gt;                我是 left            &lt;/div&gt;            &lt;div class=&quot;center&quot;&gt;                &lt;h1&gt;网格布局解决方案&lt;/h1&gt;                我是 center            &lt;/div&gt;            &lt;div class=&quot;right&quot;&gt;                我是 right            &lt;/div&gt;        &lt;/article&gt;    &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="http://img.smyhvae.com/20180305_1920.gif" srcset="/img/loading.gif" alt=""></p><h3 id="延伸：五种方法的对比"><a href="#延伸：五种方法的对比" class="headerlink" title="延伸：五种方法的对比"></a>延伸：五种方法的对比</h3><ul><li><p>五种方法的优缺点</p></li><li><p>考虑中间模块的高度问题</p></li><li><p>兼容性问题：实际开发中，哪个最实用？</p></li></ul><p>方法1：浮动：</p><ul><li><p>优点：兼容性好。</p></li><li><p>缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。</p></li></ul><p>方法:2：绝对定位</p><ul><li><p>优点：快捷。</p></li><li><p>缺点：导致子元素也脱离了标准文档流，可实用性差。</p></li></ul><p>方法3：flex 布局（CSS3中出现的）</p><ul><li>优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。</li></ul><p>方法4：表格布局</p><ul><li><p>优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局</p></li><li><p>缺点：因为三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。</p></li></ul><p>什么时候用 flex 布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。</p><p>方法5：网格布局</p><ul><li>CSS3中引入的布局，很好用。代码量简化了很多。</li></ul><p>PS：面试提到网格布局，说明我们对新技术是有追求的。</p><h3 id="延伸：如果题目中去掉高度已知"><a href="#延伸：如果题目中去掉高度已知" class="headerlink" title="延伸：如果题目中去掉高度已知"></a>延伸：如果题目中去掉高度已知</h3><p>问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？</p><p>分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。</p><p>答案是：<strong>flex 布局和表格布局可以通用</strong>，其他三个布局都不能用了。</p><h3 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h3><p><img src="http://img.smyhvae.com/20180305_1931.png" srcset="/img/loading.gif" alt=""></p><p><code>上下高度固定，中间自适应</code>，这个在移动端的页面中很常见。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>涉及到的知识点：</p><p>（1）语义化掌握到位：每个区域用<code>section</code>、<code>article</code>代表容器、<code>div</code>代表块儿。如果通篇都用 div，那就是语义化没掌握好。</p><p>（2）页面布局理解深刻。</p><p>（3）CSS基础知识扎实。</p><p>（4）思维灵活且积极上进。题目中可以通过<code>网格布局</code>来体现。</p><p>（5）代码书写规范。注意命名。上面的代码中，没有一行代码是多的。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试 00-准备</title>
    <link href="/blog/20200301/"/>
    <url>/blog/20200301/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="面试分为三部分"><a href="#面试分为三部分" class="headerlink" title="面试分为三部分"></a>面试分为三部分</h3><ul><li><p>技术面试：问技术问题。</p></li><li><p>负责人面试：考察综合能力。比如：项目把控能力、项目深度、项目架构、业务等。</p></li><li><p>hr 面试：侧重于性格、沟通、潜力等。</p></li></ul><p>每轮面试在一小时左右。</p><a id="more"></a><h3 id="每轮面试的知识点"><a href="#每轮面试的知识点" class="headerlink" title="每轮面试的知识点"></a>每轮面试的知识点</h3><p>一面：</p><blockquote><p>主要考察基础知识。</p></blockquote><ul><li><p>页面布局</p></li><li><p>CSS盒模型、DOM事件</p></li><li><p>HTTP 协议、原型链</p></li><li><p>面向对象、通信</p></li><li><p>前端安全、算法</p></li></ul><p>二面：</p><ul><li><p>渲染机制</p></li><li><p>JS 运行机制</p></li><li><p>页面性能</p></li><li><p>错误监控</p></li></ul><p>三面：</p><blockquote><p>不再关注技术层面。</p></blockquote><ul><li><p>业务能力</p></li><li><p>团队协作能力</p></li><li><p>带人能力</p></li></ul><p>终面：</p><ul><li><p>职业竞争力</p></li><li><p>职业规划</p></li></ul><p>面试成功需要：技术过关、面试技巧等。</p><h3 id="校招和社招各自看中的层面"><a href="#校招和社招各自看中的层面" class="headerlink" title="校招和社招各自看中的层面"></a>校招和社招各自看中的层面</h3><p>校招：</p><ul><li><p>知识：40%</p></li><li><p>能力：59%</p></li><li><p>经验：1%</p></li></ul><p>社招：</p><ul><li><p>知识：30%。比如协议、业务的认知程度。</p></li><li><p>能力：50%。比如架构、业务的抽象能力、项目的把控能力。</p></li><li><p>经验：20%。项目的体现。</p></li></ul><p>以上仅供参考。</p><h3 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h3><p>面试准备包括以下四个部分：</p><ul><li><p>职位描述（JD）的分析</p></li><li><p>业务分析</p></li><li><p>技术栈准备</p></li><li><p>自我介绍</p></li></ul><p>每个公司又有一套成熟的技术栈。比如在构建工具上，百度用 fis3、美团用 Gulp。</p><p>你要面哪个公司，要先看看对方要求的技术栈。</p><p>上面四个部分，我们接下来详细介绍。</p><h2 id="职位描述（JD）的分析"><a href="#职位描述（JD）的分析" class="headerlink" title="职位描述（JD）的分析"></a>职位描述（JD）的分析</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>概念：</p><ul><li><p>职位描述：注重的是工作职责。</p></li><li><p>任职要求：要求的是工作能力。通常描述得很细致。</p></li></ul><p>PS：前端的知识庞大，不可能所有的内容都准备好，但是要向“任职要求”靠拢。</p><p>分析职位描述（JD）的目的是：</p><ul><li><p>快速识别出这个岗位是否是自己喜欢的、想要的。</p></li><li><p>目前的技能是否能胜任岗位的要求。短期内的准备能否胜任。</p></li></ul><h3 id="举例1：京东-web-前端的职位描述"><a href="#举例1：京东-web-前端的职位描述" class="headerlink" title="举例1：京东 web 前端的职位描述"></a>举例1：京东 web 前端的职位描述</h3><p>如下：</p><p><img src="http://img.smyhvae.com/20180304_2132.png" srcset="/img/loading.gif" alt=""></p><p><strong>职位描述：</strong></p><p>（1）面试时，会同时考虑到 <code>PC 端和移动端</code>两个部分。</p><p>（2）<code>App H5开发</code>指的是两层意思：</p><ul><li><p>Hybrid 技术栈。</p></li><li><p>纯 H5 开发。和 native 开发没有关系，比如活动、专题。</p></li></ul><p>（3）<code>调试数据接口</code>：要学习一下怎么模拟数据。</p><p>（4）<code>前端组件库的建立</code>：要求较高但非常重要。体现在：</p><ul><li><p>基本功要扎实，原生 js、css的理解要到位。</p></li><li><p>之前有没有前端组件库相关的项目经验</p></li><li><p>是否通读过其他的 UI 组件库。</p></li></ul><p>（5）<code>优化与重构</code>：难度比第四条更大。</p><p>PS：前三条是基本知识，第四条、第五条属于进阶。</p><p><strong>任职要求：</strong></p><p>（1）<code>3年以上工作经验</code>：不要太较真工作年限。<code>精通 H5 特性</code>：说明公司很看重移动端。了解H5<code>最新规范</code>：贵公司希望我对新技术是有追求的，比如<code>ES6</code>等。</p><p>（2）要求我们对<code>面向对象</code>部分有足够的了解。组件化的编程也离不开面向对象。</p><p>（3）体现了几点：</p><ul><li><p><code>熟悉 Web 标准</code>：熟悉最新的标准即可。</p></li><li><p><code>表现与数据分离</code>：MVC框架。</p></li><li><p><code>语义化</code>：这个词千万不要忽视。不是什么都用 div。</p></li><li><p><code>实际经验</code>：利用框架开发的过程中，遇到过哪些问题？没有实际经验的话，也要提前准备几个问题。</p></li></ul><p>（4）以下几点：</p><ul><li><code>前端架构分析与设计...</code>：说明此岗位并不面对初级岗位。因为工作一至两年的人，大部分都是<strong>做业务开发</strong>，缺少<strong>系统的架构能力</strong>。</li></ul><p>我们要准备一个项目的架构（比如公司现有的项目）重新梳理，包含：目录结构的设计、复用性设计、模块化设计、自动化测试、上线流是什么。</p><ul><li><p><code>易读、易维护的代码</code>：面试过程中一定会让你写代码，来体现。要求；每个函数的功能要单一、能抽象尽量抽象。符合这两个原则，基本就满足了“易读、易维护”。</p></li><li><p><code>高质量、高效率的代码</code>，短时间内不好准备。</p></li></ul><p>（5）<code>用户可用性、用户体验、用户研究</code>：考察的不是技术，而是候选人对于产品体验的理解。不仅仅只是完成功能而已。</p><p>（6）<code>强烈兴趣</code>等，是公司企业文化的一种要求。多去GitHub上看看别人的项目里用的什么新技术、多看博客。短时间内无法准备。</p><p>（7）了解<code>Sass</code>和<code>Less</code>：这是基本技能。</p><p>（8）<strong>熟悉</strong><code>web构建工具</code>：新手推荐学习 Glup，而不是 grunt。当然，你要知道 <strong>Glup 和 grunt 的区别</strong>。</p><p>PS：了解、熟悉、精通，是有区别的。</p><p>（9）暂时可以忽略。如果 职位描述里没有要求<code>Node.js</code>，而你只会一点点 <code>Node.js</code>，那不建议你面试的时候把<code>Node.js</code>体现出来。否则是给自己挖坑。</p><h3 id="举例2：艺龙的-web-前端的职位描述"><a href="#举例2：艺龙的-web-前端的职位描述" class="headerlink" title="举例2：艺龙的 web 前端的职位描述"></a>举例2：艺龙的 web 前端的职位描述</h3><p>如下：</p><p><img src="http://img.smyhvae.com/20180304_2226.png" srcset="/img/loading.gif" alt=""></p><p>此方位</p><p><strong>职位描述：</strong></p><p>（1）<code>系统化设计</code>：说的比较笼统。其实指的就是模块化设计、前后端分离（<strong>数据渲染</strong>交给前端）。</p><p>（2）几点：</p><ul><li><p>前半句：并没有说 H5 是放在移动端做，可能同时包含 PC 和移动端。</p></li><li><p>后半句：可以看出公司对 H5 动画的要求很高。动画有三种方式：用DOM写、SVG 的path做动画、canvas。canvas 又分 2D 和 3D。我们要看岗位描述里怎么要求的。既然提到CSS3，那么CSS3里面的animation、tansition也要了解。</p></li></ul><p>（3）微信项目，要准备：</p><ul><li><p>小程序：比如看贵公司有小程序吗？我们自己要准备简单的开发和文档、组件化的内容。</p></li><li><p>微信支付。</p></li><li><p>对微信开发中的哪些坑，要了解</p></li></ul><p>（4）和京东的第四条很像，既要会框架，也要会组件化设计。但京东的侧重从零开始，而艺龙侧重于：有的就维护，没有的就开发。</p><p><strong>岗位要求：</strong></p><p>（1）<code>各种</code>web前端技术：用词不严谨。</p><p>（2）几点：</p><ul><li><p><code>Web</code>标准：JS的最新标准是ES6。</p></li><li><p><code>可用性、可访问性</code>：侧重于网站的性能。 前端要做性能监控、错误监控。JS异常分为两种：<strong>运行异常</strong>、<strong>资源加载错误</strong>。一般人只能说出第一种异常。</p></li></ul><p>（3）<code>工程化</code>：<strong>工程化</strong>已经是前端的必备技能。<code>webpack</code>是必须的工具，<code>grunt</code>已经过时了，如果公司提到，还是要了解。<code>Gulp</code>用的很多。</p><p>（4）写得比较虚，面试时基本很难考察。面试时，如果写代码，要注意代码风格，该用 class、id、标签时，要注意区分。</p><p>（5）要准备一下 Node.js。<code>至少熟悉一门</code>：可能要求全栈开发。</p><p>（6）<code>逻辑性强</code>：能说出123。</p><h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h2><blockquote><p>业务分析</p></blockquote><p>CSS3 动画是重点准备的内容。</p><p>jQuery 要准备事件委托、选择器等。</p><p>ES6语法：import、export等。</p><p>比如<a href="http://jr.jx.com/" target="_blank" rel="noopener">http://jr.jx.com/</a>这个网站：</p><p><img src="http://img.smyhvae.com/20180304_2302.png" srcset="/img/loading.gif" alt=""></p><p>通过简单分析源码，我们初步得知网站的以下几点：</p><ul><li><p>jQuery</p></li><li><p>vue 框架</p></li><li><p>ES6</p></li><li><p>webpack 打包工具</p></li></ul><h2 id="技术栈准备"><a href="#技术栈准备" class="headerlink" title="技术栈准备"></a>技术栈准备</h2><p><img src="http://img.smyhvae.com/20180310_1040.png" srcset="/img/loading.gif" alt=""></p><p>上图中，左侧是前端技术核心，右侧是前端工程化。</p><p>左侧：</p><ul><li><p>jQuery：要注意看源码。看源码时，要看这几个：核心架构、事件委托是什么、插件机制、兼容性。</p></li><li><p>三大框架：都是mvvm框架，准备一至两个即可，或者精心准备一个。面试时会问得很细。比如阿里会经常问Vue的源码。建议找网上的源码分析的文章。</p></li><li><p>Node.js：如果没有相关项目经历，就尽量不要提。</p></li></ul><p>右侧：</p><ul><li><p>npm：npm的常见命令、npm scripts 怎么用的。</p></li><li><p>webpack：有个中文网站，讲的内容比较全。</p></li></ul><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试问的问题，很大层次上，取决你的简历和自我介绍。</p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历中最重要的四个信息：</p><ul><li><p>基本信息：姓名、年龄、手机、邮箱、籍贯。</p></li><li><p>学历：从大到小写。硕士 -&gt; 本科。</p></li><li><p>工作经历：时间、公司、岗位、职责、技术栈、<strong>业绩</strong>。业绩是大多数人所忽略的。</p></li><li><p>开源项目、Github、说明。</p></li></ul><p>自我评价可以不写。</p><p>项目的业绩上，要包括：<strong>技术收益</strong>和<strong>业绩收益</strong>。</p><h3 id="自我陈述"><a href="#自我陈述" class="headerlink" title="自我陈述"></a>自我陈述</h3><p>1、<strong>把握面试的沟通方向。</strong></p><p>如果陈述中谈到项目，面试官可能会问：</p><ul><li><p>负责了什么项目，项目是做什么的</p></li><li><p>和前端的结合点是？你的角色是？项目中承担了什么责任？</p></li><li><p>你在项目中的成绩？</p></li></ul><p>如果你说自己是项目<code>负责人</code>，会被问到：</p><ul><li><p>该项目怎么分配？有几个人参与？</p></li><li><p>作为负责人，你的角色是什么？是项目管理还是技术管理？</p></li><li><p>遇到技术难点，如何解决？</p></li></ul><h3 id="提问题"><a href="#提问题" class="headerlink" title="提问题"></a>提问题</h3><p>如果在深入问题时，碰到不会的，不要说“我不知道”。建议回答：</p><ul><li><p><strong>我要回去思考一下</strong>。</p></li><li><p>这方面我没有经验，能不能<strong>指点一下</strong>？</p></li><li><p>有什么建议或者参考资料吗？我想把这个东西弄懂。</p></li></ul><p>2、阔达、自信的适度发挥。</p><blockquote><p>本文转载自<a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 05</title>
    <link href="/blog/20200211/"/>
    <url>/blog/20200211/</url>
    
    <content type="html"><![CDATA[<p>第九章 模板<br>第十章 流类库和输入输出</p><a id="more"></a><h1 id="第九章-模板"><a href="#第九章-模板" class="headerlink" title="第九章 模板"></a>第九章 模板</h1><h2 id="9-1-模板的概念"><a href="#9-1-模板的概念" class="headerlink" title="9.1 模板的概念"></a>9.1 模板的概念</h2><p>模板是实现代码复用的一种工具，它可以实现类型参数化，把类型定义为参数，实现代码的真正复用。<br>模板分两类：函数模板和类模板。用一个代码段指定一组函数称为函数模板，或用一个代码段指定一组相关类称为类模版。</p><h2 id="9-2-函数模板的定义与使用"><a href="#9-2-函数模板的定义与使用" class="headerlink" title="9.2 函数模板的定义与使用"></a>9.2 函数模板的定义与使用</h2><h3 id="9-2-1-函数模板的定义"><a href="#9-2-1-函数模板的定义" class="headerlink" title="9.2.1 函数模板的定义"></a>9.2.1 函数模板的定义</h3><p>格式为：</p><pre><code>template &lt;typename(或 class) 数据类型参数标识符&gt;&lt;返回类型&gt;&lt;函数名&gt;(参数表){函数体}</code></pre><h3 id="9-2-2-模板函数"><a href="#9-2-2-模板函数" class="headerlink" title="9.2.2 模板函数"></a>9.2.2 模板函数</h3><p>在使用函数模板时，要将形参“数据类型参数标识符”实例化为确定的数据类型。<br>将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。</p><h3 id="9-2-3-重载模板函数"><a href="#9-2-3-重载模板函数" class="headerlink" title="9.2.3 重载模板函数"></a>9.2.3 重载模板函数</h3><p>函数模板可使用多种方式重载。可以使用其它函数模板，指定不同参数的相同函数名。也可以用非模板函数重载。</p><ol><li>用非模板函数重载函数模板有两种方法：<ul><li>借用函数模板的函数体，只声明非模板函数的原型，它的函数体借用函数模板的函数体。</li><li>重新定义函数体。即重新定义一个完整的非模板函数，它所带的参数可以随意。</li></ul></li><li>在 C++中，函数模板与同名的非模板函数重载时，应遵循下列调用原则：<br>首先寻找一个参数完全匹配的函数，若找到就调用它。<br>若找不到，则寻找一个函数模板，将其实例化生成一个匹配的模板函数，若找到就调用它。<br>若找不到，则从第一步中通过类型转换产生参数匹配，若找到就调用它。否则调用失败。</li></ol><h2 id="9-3-类模板的定义和使用"><a href="#9-3-类模板的定义和使用" class="headerlink" title="9.3    类模板的定义和使用"></a>9.3 类模板的定义和使用</h2><h3 id="9-3-1-类模板的定义"><a href="#9-3-1-类模板的定义" class="headerlink" title="9.3.1 类模板的定义"></a>9.3.1 类模板的定义</h3><p>格式为：</p><pre><code>template&lt;class 数据类型参数标识符&gt; class 类名{//……}；</code></pre><h3 id="9-3-2-模板类"><a href="#9-3-2-模板类" class="headerlink" title="9.3.2 模板类"></a>9.3.2 模板类</h3><p>将类模板的模板参数实例化后生成的具体的类，就是模板类。由类模板生成模板类的一般形式为：<br>类名&lt;模板实参表&gt; 对象名 1，对象名 2，…，对象名 n；</p><h1 id="第十章-流类库和输入输出"><a href="#第十章-流类库和输入输出" class="headerlink" title="第十章 流类库和输入输出"></a>第十章 流类库和输入输出</h1><h2 id="10-1-流的概念及流类库"><a href="#10-1-流的概念及流类库" class="headerlink" title="10.1 流的概念及流类库"></a>10.1 流的概念及流类库</h2><h3 id="10-1-1-流的概念"><a href="#10-1-1-流的概念" class="headerlink" title="10.1.1 流的概念"></a>10.1.1 流的概念</h3><p>C++中的流是指数据从一个对象传递到另一个对象的操作。从流中读取数据称为提取操作，向流内添加数据称为插入操作。<br>流在使用前要建立，使用后要删除。如果数据的传递是在设备之间进行，这种流就称为 I/O 流。<br>C++专门内置了一些供用户使用的类，在这些类中封装了可以实现输入输出操作的函数，这些类统称为 I/O 流类。<br>C++流预定义了 4 个标准流类对象，它们可以直接用来输入输出。这些标准流类对象都包含在头文件 iostream.h 中。<br>istream cin; //与标准输入设备相关联的标准输入流。<br>ostream cout; //与标准输出设备相关联的标准输出流。<br>ostream cerr; //与标准错误输出设备相关联的非缓冲方式的标准输出流。<br>ostream clog; //与标准错误输出设备相关联的缓冲方式的标准输出流。</p><h3 id="10-1-2-流类库"><a href="#10-1-2-流类库" class="headerlink" title="10.1.2    流类库"></a>10.1.2 流类库</h3><p>C++的流类库有两个平行的基类 streambuf 和 ios，其它的流类都是从这两个基类直接或间接派生的。<br>使用这些流类库时，必须包含相应的头文件。</p><h2 id="10-2-输入输出的格式控制"><a href="#10-2-输入输出的格式控制" class="headerlink" title="10.2    输入输出的格式控制"></a>10.2 输入输出的格式控制</h2><p>C++仍可使用 C 中的 printf()和 scanf()进行格式化控制，同时又提供了两种格式化控制的方法，<br>一是使用 ios 类中的有关格式控制的成员函数，二是使用执行格式化输入/输出的格式控制符。</p><h3 id="10-2-1-用-ios-类的成员函数进行格式控制"><a href="#10-2-1-用-ios-类的成员函数进行格式控制" class="headerlink" title="10.2.1    用 ios 类的成员函数进行格式控制"></a>10.2.1 用 ios 类的成员函数进行格式控制</h3><p>使用这种方式进行格式控制主要是通过设置及清除格式状态标志、设置域宽、设置填充字符和设置输出精度的操作来完成的。</p><h3 id="10-2-2-用格式控制符进行格式控制"><a href="#10-2-2-用格式控制符进行格式控制" class="headerlink" title="10.2.2    用格式控制符进行格式控制"></a>10.2.2 用格式控制符进行格式控制</h3><ul><li>预定义的格式控制符</li><li>自定义的格式控制符</li></ul><h2 id="10-3-输入与输出运算符的重载"><a href="#10-3-输入与输出运算符的重载" class="headerlink" title="10.3 输入与输出运算符的重载"></a>10.3 输入与输出运算符的重载</h2><ol><li>定义运算符“&lt;&lt;”重载函数的一般形式为：<pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;stream,类名 对象名){//操作代码return stream;}</code></pre></li><li>定义运算符“&gt;&gt;”重载函数的一般形式为：<pre><code class="istream">{//操作代码return stream;}</code></pre></li></ol><h2 id="10-4-文件操作"><a href="#10-4-文件操作" class="headerlink" title="10.4    文件操作"></a>10.4 文件操作</h2><h3 id="10-4-1-创建文件流"><a href="#10-4-1-创建文件流" class="headerlink" title="10.4.1 创建文件流"></a>10.4.1 创建文件流</h3><p>在 C++中进行文件操作，要包含&lt;fstream.h&gt;。该头文件包括了 ifstream（从文件输入）、ofstream（向文件输出）、<br>fstream（从文件输入输出）流类的定义。它们分别派生自 istream、ostream、iostream。<br>建立文件流就是定义文件流类的对象。如<br>ifstream fin; ofstream fout; fstream fio;<br>建立了流以后，就可以把某一个流与文件建立联系，进行文件的读写操作了。</p><h3 id="10-4-2-文件的打开与关闭"><a href="#10-4-2-文件的打开与关闭" class="headerlink" title="10.4.2 文件的打开与关闭"></a>10.4.2 文件的打开与关闭</h3><p>可以在定义文件流对象的同时完成打开文件的工作，也可在定义文件流对象以后通过open()函数完成。<br>open()函数是上述三个流类的成员函数，定义在 fstream.h 头文件中。<br>函数原型为：<code>void open(const unsigned char *,int mode,int dcces=filebuf::openprot);</code><br>说明：第一个参数用来传递文件名；第二个参数的值决定文件打开的方式，必须从下列值中选取：<br>ios::app //使输出追加到文件尾部，只用于输出<br>ios::ate //查找文件尾<br>ios::in //打开一个文件进行读操作，只用于输入<br>ios::nocreate //文件不存在，导致 open()失败<br>ios::noreplace //若文件存在，则 open()失败<br>ios::out //打开一个文件进行写操作，只用于输出<br>ios::trunc //删除同名文件<br>ios::binary //以二进制方式打开文件，缺省为文本方式以上各值可以组合使用，之间用“|”分开。</p><h3 id="10-4-3-文件的读写"><a href="#10-4-3-文件的读写" class="headerlink" title="10.4.3 文件的读写"></a>10.4.3 文件的读写</h3><ul><li>文件的顺序读写<br>get()函数 ：它从流中每次读出一个字节或一个字符放入引用 ch&amp;中。<br>put()函数：它将一个字节或一个字符写入流中。<br>read()函数：从相应的流读出 num 个字节或字符的数据，把他们放入指针所指向的缓冲区中。<br>buf 是一个指向读入数据存放空间的指针，num 说明要读入数据的字节或字符数。<br>write()函数：从 buf 所指向的缓冲区把 num 个字节的数据写到相应的流中。<br>参数的含义、调用及注意事项与 read()相同。</li><li>文件的随机读写<br>完成定位操作的函数如下：<br>函数 seekg()：用于输入文件，将文件的读指针从 origin 说明的位置移动 offset 个字节；<br>函数 seekp()：用于输出文件，将文件的写指针从 origin 说明的位置移动 offset 个字节。<br>函数 tellg()：用于输入文件，确定文件当前指针的位置。<br>函数 tellp()：用于输出文件，确定文件当前指针的位置。</li></ul>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 04</title>
    <link href="/blog/20200210/"/>
    <url>/blog/20200210/</url>
    
    <content type="html"><![CDATA[<p>第七章 继承性与派生类<br>第八章 多态性与虚函数</p><a id="more"></a><h1 id="第七章-继承性与派生类"><a href="#第七章-继承性与派生类" class="headerlink" title="第七章 继承性与派生类"></a>第七章 继承性与派生类</h1><h2 id="7-1-继承性与派生类的基本概念"><a href="#7-1-继承性与派生类的基本概念" class="headerlink" title="7.1 继承性与派生类的基本概念"></a>7.1 继承性与派生类的基本概念</h2><p>继承是软件复用的一种形式，它是从现有类的基础上建立新类，新类继承了现有类的属性和方法，<br>并且还拥有其特有的属性和方法。继承的过程称为派生，新建的类为派生类（或子类），原有的类称为基类（或父类）。<br>继承可分为：单继承和多重继承。若派生类只有一个基类则称为单继承；若派生类有多个基类则称为多重继承。</p><h2 id="7-2-派生类的声明与访问权限"><a href="#7-2-派生类的声明与访问权限" class="headerlink" title="7.2 派生类的声明与访问权限"></a>7.2 派生类的声明与访问权限</h2><h3 id="7-2-1-派生类的声明"><a href="#7-2-1-派生类的声明" class="headerlink" title="7.2.1    派生类的声明"></a>7.2.1 派生类的声明</h3><p>单继承中派生类的定义格式为：</p><pre><code>class &lt;派生类名&gt;：&lt;派生方式&gt;&lt;基类名&gt;{派生类新定义的成员声明；}；</code></pre><h3 id="7-2-2-派生类的访问权限"><a href="#7-2-2-派生类的访问权限" class="headerlink" title="7.2.2    派生类的访问权限"></a>7.2.2 派生类的访问权限</h3><p>公有继承（public）、私有继承（private）、保护继承（protected）</p><h2 id="7-3-派生类构造函数和析构函数的定义及使用"><a href="#7-3-派生类构造函数和析构函数的定义及使用" class="headerlink" title="7.3    派生类构造函数和析构函数的定义及使用"></a>7.3 派生类构造函数和析构函数的定义及使用</h2><p>在派生过程中，构造函数和析构函数不被继承。在创建一个派生类对象时，分别调用基类和派生类的构造函数，<br>完成各自成员的初始化工作。当撤销一个派生类对象时，分别调用基类和派生类的析构函数完成善后处理工作。</p><ul><li>在 C++中对构造函数与析构函数的调用顺序有如下规定：<br>对于构造函数，先执行基类的，再执行对象成员的，最后执行派生类的。<br>对于析构函数，先执行派生类的，再执行对象成员的，最后执行基类的。</li><li>派生类构造函数定义格式为：<pre><code>&lt;派生类名&gt;::&lt;派生类名&gt;(参数总表):基类名(参数表),对象成员名 1(参数表 1),…,对象成员名 n(参数表 n){//派生类新增成员的初始化语句}</code></pre></li></ul><h2 id="7-4-多重继承的声明、构造函数和析构函数的定义及使用"><a href="#7-4-多重继承的声明、构造函数和析构函数的定义及使用" class="headerlink" title="7.4    多重继承的声明、构造函数和析构函数的定义及使用"></a>7.4 多重继承的声明、构造函数和析构函数的定义及使用</h2><h3 id="7-4-1-多重继承的声明"><a href="#7-4-1-多重继承的声明" class="headerlink" title="7.4.1    多重继承的声明"></a>7.4.1 多重继承的声明</h3><p>多重继承声明的格式为：</p><pre><code>class &lt;派生类名&gt;：&lt;派生方式 1&gt;&lt;基类名 1&gt;,…,&lt;派生方式 n&gt;&lt;基类名 n&gt;{派生类成员声明；};</code></pre><p>说明：这里的派生方式以及访问权限定义与单继承中规则相同。</p><h3 id="7-4-2-多重继承的构造函数与析构函数"><a href="#7-4-2-多重继承的构造函数与析构函数" class="headerlink" title="7.4.2    多重继承的构造函数与析构函数"></a>7.4.2 多重继承的构造函数与析构函数</h3><ul><li>多重继承中对构造函数和析构函数的调用顺序的规定：<br>对于构造函数，先执行基类的，再执行对象成员的，最后执行派生类的。<br>多个基类构造函数的执行次序严格按照声明时从左到右的顺序来执行的，与定义派生类构造函数时指定的初始化表中的次序无关。<br>多个对象成员所在类的构造函数的执行次序按照对象成员定义的顺序来执行。<br>析构函数的调用顺序正好与构造函数的调用顺序相反。</li><li>定义多重继承构造函数的格式为：<pre><code>&lt;派生类名&gt;::&lt;派生类名&gt;(参数总表):基类名 1(参数表 1),…,基类名 n(参数表 n),对象成员名 1(对象成员参数表 1),…,对象成员名 m(对象成员参数表 m){//派生类新增成员的初始化语句}</code></pre>说明：单继承中构造函数定义的说明在多重继承构造函数中均适用。</li></ul><h2 id="7-5-虚基类的作用、定义和使用"><a href="#7-5-虚基类的作用、定义和使用" class="headerlink" title="7.5    虚基类的作用、定义和使用"></a>7.5 虚基类的作用、定义和使用</h2><h3 id="7-5-1-多重继承中的二义性问题"><a href="#7-5-1-多重继承中的二义性问题" class="headerlink" title="7.5.1    多重继承中的二义性问题"></a>7.5.1 多重继承中的二义性问题</h3><p>问题的产生：</p><ol><li>当派生类继承的多个基类中存在同名成员时，派生类中就会出现来自不同基类的同名成员，<br>就出现了标识符不唯一或二义性的情况，这在程序中是不允许的。</li><li>当一个类从多个基类派生而来，这多个基类又有共同的基类，则在派生类中访问这个共同基类中的成员时会产生二义性。<br>解决办法：<br>对于第一种情况：</li><li>使用作用域运算符“::”</li><li>使用同名覆盖的原则</li><li>使用虚函数(在下一章中介绍)<br>对于第二种情况：<br>使用虚基类</li></ol><h3 id="7-5-2-虚基类"><a href="#7-5-2-虚基类" class="headerlink" title="7.5.2 虚基类"></a>7.5.2 虚基类</h3><p><img src="/img/C++7_5_2.png" srcset="/img/loading.gif" alt="C++7_5_2"><br>如上图所示，对于非虚基类的情况，derived 有两个基类 base1 和 base2，这两个基类又有共同基类 base，<br>derived 类中就有基类 base 的两个不同的拷贝。在 derived 要访问 base 类中的成员时，就会产生二义性问题。<br>虚基类就是为了解决这个问题而引入的。<br>对于虚基类的情况，derived 中的公共基类 base 就只有一个拷贝而不会出现二义性问题。</p><h3 id="7-5-3-虚基类的定义"><a href="#7-5-3-虚基类的定义" class="headerlink" title="7.5.3 虚基类的定义"></a>7.5.3 虚基类的定义</h3><p>虚基类的声明是在派生类的声明过程中进行的，格式为：<br>class&lt;派生类名&gt;:virtual &lt;派生方式&gt;&lt;基类名&gt;<br>说明：</p><ol><li>虚基类关键字的作用范围和派生方式与一般派生类的一样，只对紧跟其后的基类起作用。</li><li>声明了虚基类以后，虚基类的成员在进一步派生过程中和派生类一起维护同一个内存拷贝。</li></ol><h3 id="7-5-4-虚基类的构造函数和初始化"><a href="#7-5-4-虚基类的构造函数和初始化" class="headerlink" title="7.5.4 虚基类的构造函数和初始化"></a>7.5.4 虚基类的构造函数和初始化</h3><p>虚基类的初始化与一般的多继承的初始化在语法上是一样的，但构造函数的执行顺序不同：</p><ol><li>虚基类的构造函数在非虚基类的构造函数之前执行。</li><li>若同一层次中包含多个虚基类，这些虚基类的构造函数按它们说明的先后次序执行。</li><li>若虚基类由非虚基类派生而来，则仍然先执行基类的构造函数，再执行派生类的构造函数。</li></ol><h1 id="第八章-多态性与虚函数"><a href="#第八章-多态性与虚函数" class="headerlink" title="第八章 多态性与虚函数"></a>第八章 多态性与虚函数</h1><h2 id="8-1-多态性的概念"><a href="#8-1-多态性的概念" class="headerlink" title="8.1    多态性的概念"></a>8.1 多态性的概念</h2><p>在面向对象的概念中，多态性是指不同对象接收到相同消息时，根据对象类的不同产生不同的动作。<br>由静态联编支持的多态性称为编译时的多态性或静态多态性，也就是说，确定同名操作的具体操作对象的过程是<br>在编译过程中完成的。C++用函数重载和运算符重载来实现编译时的多态性。<br>由动态联编支持的多态性称为运行时的多态性活动或动态多态性，<br>也就是说，确定同名操作的具体操作对象的过程是在运行过程中完成的。C++用继承和虚函数来实现运行时的多态性。</p><h2 id="8-2-函数和运算符的重载"><a href="#8-2-函数和运算符的重载" class="headerlink" title="8.2 函数和运算符的重载"></a>8.2 函数和运算符的重载</h2><h3 id="8-2-1-函数重载"><a href="#8-2-1-函数重载" class="headerlink" title="8.2.1 函数重载"></a>8.2.1 函数重载</h3><p>面向对象程序设计中，函数的重载表现为两种情况：第一种是参数个数或类型有所差别的重载，第二种是函数的参数完全相同但属于不同的类。</p><h3 id="8-2-2-运算符重载"><a href="#8-2-2-运算符重载" class="headerlink" title="8.2.2 运算符重载"></a>8.2.2 运算符重载</h3><p>C++预定义的运算符只是对基本数据类型进行操作，而对于自定义的数据类型比如类，却没有类似的操作。<br>为了实现对自定义类型的操作，就必须自己编写程序来说明某个运算符作用在这些数据类型上时，<br>应该完成怎样的操作，这就要引入运算符重载的概念。<br>运算符的重载形式有两种，一种是重载为类的成员函数，一种是重载为类的友元函数。</p><ol><li><p>将运算符重载为它将要操作的类的成员函数，称为成员运算符函数。<br>实际使用时，总是通过该类的某个对象访问重载的运算符。<br>成员运算符函数的定义：<br>在类内声明的一般形式为：&lt;返回类型&gt; operator&lt;运算符&gt;(参数表)；<br>在类外定义的一般形式为：</p><pre><code>&lt;返回类型&gt; &lt;类名∷&gt; operator&lt;运算符&gt;(参数表){函数体}</code></pre><p>其中，operator 是定义运算符重载函数的关键字；运算符是要重载的运算符的名称；参数表给出重载运算符所需要的参数和类型。</p></li><li><p>将重载的运算符函数定义为类的友元函数，称为友元运算符函数。<br>友元运算符函数不是类的成员，它在类内声明原型，在类外定义函数本身。由于它不是类的成员函数，<br>不属于任何一个类对象，所以没有 this 指针，因此，重载双目运算符时要有两个参数，重载单目运算符时只要一个参数就可以了。<br>友员运算符函数的定义：<br>在类内声明的一般形式为：<br>friend&lt;返回类型&gt; operator&lt;运算符&gt;(参数表)；<br>在类外定义的一般形式为：</p><pre><code>&lt;返回类型&gt; operator&lt;运算符&gt;(参数表){函数体}</code></pre><p>其中，friend 是声明友元函数的关键字， operator 是定义运算符重载函数的关键字；<br>运算符是要重载的运算符的名称；参数表给出重载运算符所需要的参数和类型。</p></li><li><p>几种典型运算符的重载</p><ul><li>加法运算符“+”的重载</li><li>“++”和“–”的重载</li><li>赋值运算符“=”的重载</li><li>函数调用运算符“（）”的重载</li><li>下标运算符“[ ]”的重载</li></ul></li></ol><h2 id="8-3-虚函数和抽象类"><a href="#8-3-虚函数和抽象类" class="headerlink" title="8.3 虚函数和抽象类"></a>8.3 虚函数和抽象类</h2><p>虚函数是重载的另一种形式，实现的是动态的重载，即函数调用与函数体之间的联系是在运行时才建立，也就是动态联编。</p><h3 id="8-3-1-虚函数的定义和使用"><a href="#8-3-1-虚函数的定义和使用" class="headerlink" title="8.3.1 虚函数的定义和使用"></a>8.3.1 虚函数的定义和使用</h3><p>虚函数的定义是在基类中进行的，即把基类中需要定义为虚函数的成员函数声明为virtual。<br>当基类中的某个成员函数被声明为虚函数后，它就可以在派生类中被重新定义。<br>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和类型、参数的顺序都必须与基类中的原型完全一致。<br>虚函数定义的一般形式为：</p><pre><code>virtual&lt;函数类型&gt;&lt;函数名&gt;(参数表){函数体}</code></pre><h3 id="8-3-2-纯虚函数和抽象类"><a href="#8-3-2-纯虚函数和抽象类" class="headerlink" title="8.3.2 纯虚函数和抽象类"></a>8.3.2 纯虚函数和抽象类</h3><p>抽象类是一种特殊的类，它为一族类提供统一的操作界面，建立抽象类就是为了通过它多态地使用其中的成员函数。抽象类是带有纯虚函数的类。<br>一个抽象类至少带有一个纯虚函数。纯虚函数是在一个基类中说明的虚函数，它在该基类中没有具体的操作内容，<br>要求各派生类在重新定义时根据自己的需要定义实际的操作内容。<br>纯虚函数的一般定义形式为：virtual&lt;函数类型&gt;&lt;函数名&gt;(参数表)=0；<br>纯虚函数与普通虚函数的定义的不同在于书写形式上加了“=0”，说明在基类中不用定义该函数的函数体，它的函数体由派生类定义。<br>如果一个类中至少有一个纯虚函数，这个类就成为抽象类。它的主要作用是为一个族类提供统一的公共接口，以有效地发挥多态的特性。</p>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 03</title>
    <link href="/blog/20200209/"/>
    <url>/blog/20200209/</url>
    
    <content type="html"><![CDATA[<p>第六章 类和对象的创建</p><a id="more"></a><h1 id="第六章-类和对象的创建"><a href="#第六章-类和对象的创建" class="headerlink" title="第六章 类和对象的创建"></a>第六章 类和对象的创建</h1><h2 id="6-1-类和对象"><a href="#6-1-类和对象" class="headerlink" title="6.1 类和对象"></a>6.1 类和对象</h2><h3 id="6-1-1-类的定义"><a href="#6-1-1-类的定义" class="headerlink" title="6.1.1 类的定义"></a>6.1.1 类的定义</h3><p>类实质上是用户自定义的一种特殊的数据类型，它不仅包含相关的数据，还包含能对这<br>些数据进行处理的函数，同时，这些数据具有隐蔽性和封装性。<br>类中包含的数据和函数统称为成员，数据称为数据成员，函数称为成员函数，它们都有自己的访问权限。<br>类定义一般分为两部分，即说明部分和实现部分。说明部分用于说明该类中的成员，实现部分用于对成员函数进行定义。</p><ul><li><p>类定义格式</p><pre><code>class 类名{  private:  私有数据成员和成员函数  protected:  保护数据成员和成员函数  public:  公有数据成员和成员函数};各成员函数的实现</code></pre></li><li><p>类成员的访问控制<br>类成员有三种不访问权限：私有（private）、保护（protected）、公有（public）。</p></li><li><p>类的数据成员与成员函数<br>类定义中声明数据成员的数据类型和名称，不能在类内说明数据成员的同时为其赋初值，<br>只有在类的对象定义以后才能给数据成员赋初值。对于成员函数可以在类内定义，<br>也可以在类内给出函数原型，然后在类外对成员函数进行定义。<br>成员函数在类内说明原型，在类外给出定义时其定义格式如下：</p><pre><code>返回类型 类名::函数名 参数表{ //函数体}</code></pre></li></ul><h3 id="6-1-2-对象的定义和使用"><a href="#6-1-2-对象的定义和使用" class="headerlink" title="6.1.2 对象的定义和使用"></a>6.1.2 对象的定义和使用</h3><p>对象的定义：类定义只是定义了一种新的数据类型，只有定义了类的实例即类的对象以后系统才会为该对象分配存储空间。<br>对象定义可以在类定义的同时直接完成，即在类定义的最后“}”后直接跟对象名列表；<br>也可以在类定义后要使用该对象时定义。<br>格式：类名对象名（参数列表）；<br>说明：可以同时定义多个对象，之间用逗号隔开。<br>对象成员的引用<br>格式：<br>对象名.数据成员；<br>对象名.成员函数（实参表）；</p><h2 id="6-2-构造函数和析构函数"><a href="#6-2-构造函数和析构函数" class="headerlink" title="6.2 构造函数和析构函数"></a>6.2 构造函数和析构函数</h2><h3 id="6-2-1-构造函数"><a href="#6-2-1-构造函数" class="headerlink" title="6.2.1 构造函数"></a>6.2.1 构造函数</h3><p>构造函数是一种特殊的成员函数，被声明为公有成员，其作用是为类的对象分配内存空间，进行初始化。<br>关于构造函数有以下几点说明：</p><ol><li>构造函数的名字必须与类的名字相同。</li><li>构造函数没有返回值，不能定义返回类型，包括 void 型在内。</li><li>对象定义时，编译系统会自动地调用构造函数完成对象内存空间的分配和初始化工作。</li><li>构造函数是类的成员函数，具有一般成员函数的所有性质，可访问类的所有成员，<br>可以是内联函数，可带有参数表，可带有默认的形参值，还可重载。</li><li>如果没有定义构造函数，编译系统就自动生成一个缺省的构造函数，这个缺省的构造函数不带任何参数，<br>仅给对象开辟存储空间，不完成对数据成员赋初值。此时数据成员的值是随机的。<br>系统自动生成的构造函数的形式为：<pre><code> 类名∷类名() { }</code></pre></li></ol><h3 id="6-2-2-析构函数"><a href="#6-2-2-析构函数" class="headerlink" title="6.2.2 析构函数"></a>6.2.2 析构函数</h3><p>析构函数也是一种特殊的成员函数，也被声明为公有成员，其作用是释放分配给对象的内存空间，并做一些善后工作。<br>关于析构函数有以下几点说明：</p><ol><li>析构函数的名字必须是 ~类名。</li><li>析构函数没有参数、没有返回值、不能重载。</li><li>当对象撤销时，系统会自动调用析构函数完成内存空间的释放和善后工作。</li><li>如果没有定义析构函数，系统会自动生成一个缺省的空析构函数。完成善后工作，其形式为：<pre><code>类名::~类名(){}</code></pre>对于构造函数和析构函数常见用法是在构造函数中用 new 动态申请空间，<br>在析构函数中用 delete 释放内存空间。</li></ol><h3 id="6-2-3-拷贝构造函数"><a href="#6-2-3-拷贝构造函数" class="headerlink" title="6.2.3 拷贝构造函数"></a>6.2.3 拷贝构造函数</h3><p>拷贝构造函数是一个特殊的构造函数，其作用是用一个已经存在的对象初始化本类的新对象。<br>每个类都有一个拷贝构造函数，它可以是根据用户的需要自定义，也可以由系统自动生成。<br>拷贝构造函数名与类名相同，但参数是本类对象的引用。拷贝构造函数没有返回值。<br>定义拷贝构造函数的格式为：</p><pre><code>类名(类名&amp;对象名){//函数体}</code></pre><p>其中，对象名是用来初始化另一个对象的对象的引用。<br>构造函数只在对象被创建时自动调用，而拷贝构造函数在下列三种情况下会被自动调用：</p><ol><li>用一个对象去初始化本类的另一个对象时。</li><li>函数的形参是类的对象，在进行形参和实参的结合时。</li><li>函数的返回值是类的对象，函数执行完返回时。</li></ol><h3 id="6-2-4-对象成员"><a href="#6-2-4-对象成员" class="headerlink" title="6.2.4 对象成员"></a>6.2.4 对象成员</h3><ul><li><p>定义对象成员<br>当用一个类的对象作为另一个类的成员时，该成员称为对象成员。声明对象成员的一般格式为：</p><pre><code>class 类名{类名 1    对象成员名 1；//需要此类在前面已经定义或声明。．．．}；</code></pre></li><li><p>对象成员的初始化<br>在类中有对象成员时，创建本类的对象则本类的构造函数要调用其对象成员所在类的构造函数，<br>并采用成员初始化列表对对象成员进行初始化。这种类的构造函数的定义格式为：</p><pre><code>类名∷类名(参数总表)：对象成员 1(形参表)，．．．，对象成员ｎ(形参表){//构造函数体}</code></pre></li></ul><h2 id="6-3-对象数组与对象指针"><a href="#6-3-对象数组与对象指针" class="headerlink" title="6.3 对象数组与对象指针"></a>6.3 对象数组与对象指针</h2><h3 id="6-3-1-对象数组"><a href="#6-3-1-对象数组" class="headerlink" title="6.3.1 对象数组"></a>6.3.1 对象数组</h3><p>对象数组是指数组中的每个元素都是一个类的对象。当然这些对象属于同一个类。</p><ul><li>定义一维对象数组的一般格式为：<br>类名 数组名[常量表达式]；</li><li>对象数组的引用<br>由于对象数组的元素是对象，只能访问其公有成员。<br>引用格式为： 数组名[下标]．公有成员</li></ul><h3 id="6-3-2-对象指针"><a href="#6-3-2-对象指针" class="headerlink" title="6.3.2 对象指针"></a>6.3.2 对象指针</h3><p>对象指针就是对象在内存中的首地址。指向类类型的指针变量用于存放对象指针。<br>其定义格式为：&lt;类名&gt; * &lt;指针变量名&gt;;</p><h2 id="6-4-静态成员"><a href="#6-4-静态成员" class="headerlink" title="6.4 静态成员"></a>6.4 静态成员</h2><p>静态成员是指类中用关键字static说明的那些成员。静态成员仍然服从访问控制。</p><h3 id="6-4-1-静态数据成员"><a href="#6-4-1-静态数据成员" class="headerlink" title="6.4.1 静态数据成员"></a>6.4.1 静态数据成员</h3><p>静态数据成员是指类中用关键字static说明的那些数据成员。<br>静态数据成员属于类而不属于某个对象。它实现同类对象之间的数据共享。</p><ul><li>在类中声明静态数据成员时，必须加 static 说明。</li><li>对静态数据成员初始化只能在类外进行，一般在在类声明与 main()之间的位置。<br>格式为：数据类型 类名∷静态数据成员名=值；</li><li>对静态数据成员的引用可以有两种形式：<br>类名∷静态数据成员 对象名．静态数据成员</li></ul><h3 id="6-4-2-静态成员函数"><a href="#6-4-2-静态成员函数" class="headerlink" title="6.4.2 静态成员函数"></a>6.4.2 静态成员函数</h3><p>静态成员函数是指类中用关键字static说明的那些成员函数。可以用静态成员函数在未建立任何对象之前去处理静态数据成员。<br>静态成员函数只能直接引用该类的静态数据成员和静态成员函数，不能直接引用非静态数据成员。<br>调用静态的两种形式：类名∷静态函数名(); 或 对象名．静态函数名();</p><h2 id="6-5-友元"><a href="#6-5-友元" class="headerlink" title="6.5 友元"></a>6.5 友元</h2><p>C++引入了友元实现了在类的外部访问类的私有成员的功能。这样，即不放弃私有数据的安全性，又可在类的外部访问类的私有成员。<br>但一定程度上说友元破坏了类的封装性，在使用友元时一定要慎重。友元关系是单向的，也是不能传递的。</p><h3 id="6-5-1-友元函数"><a href="#6-5-1-友元函数" class="headerlink" title="6.5.1 友元函数"></a>6.5.1 友元函数</h3><p>一个普通函数作为某个类的友元时即为友元函数。在该函数中可以访问其由 friend 声明语句所在的类的对象的私有成员和公有成员。<br>在类中作如下声明，则说明该函数不是本类的成员函数，而是友元函数。<br>friend 函数类型 友元函数名(参数表);<br>友元函数的定义可以在类内也可以在类外，在类外定义时不需要加类名和普通函数定义没有区别。<br>通常友元函数的定义在类外进行。友元函数不是类的成员，因而不能直接引用对象成员的名字，<br>也不能通过 this 指针引用对象的成员，必须通过作为入口参数传递进来的对象名或对象指针来引用该对象的成员。<br>为此，友元函数一般都带有一个该类的入口参数。</p><h3 id="6-5-2-友元成员函数"><a href="#6-5-2-友元成员函数" class="headerlink" title="6.5.2    友元成员函数"></a>6.5.2 友元成员函数</h3><p>某个类的成员函数作为另一个类的友元即为友元成员函数。通过友元成员函数，可以访问由 friend 声明语句所在的类的对象的私有成员和公有成员。<br>当一个类 A 的成员函数作为另一个类 B 的友元函数时，在类 B 中的声明格式为：<br>friend 函数类型 成员函数所在类类名::函数名（参数表）；</p><h3 id="6-5-3-友类"><a href="#6-5-3-友类" class="headerlink" title="6.5.3    友类"></a>6.5.3 友类</h3><p>当一个类作为另一个类的友元时即为友类。若类 A 是类 B 的友类，则类 A 中的所有成员函数都是类 B 的友元成员函数，<br>所以可以通过对象名访问 B 的私有成员和公有成员。当类 A 为类B 的友类时，在类 B 中的声明格式为：<br>firiend class &lt;友元类名&gt;; 或 friend &lt;友元类名&gt;;</p>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 02</title>
    <link href="/blog/20200208/"/>
    <url>/blog/20200208/</url>
    
    <content type="html"><![CDATA[<p>第五章 指针、引用和动态空间管理</p><a id="more"></a><h1 id="第五章-指针、引用和动态空间管理"><a href="#第五章-指针、引用和动态空间管理" class="headerlink" title="第五章 指针、引用和动态空间管理"></a>第五章 指针、引用和动态空间管理</h1><h2 id="5-1-指针概述"><a href="#5-1-指针概述" class="headerlink" title="5.1 指针概述"></a>5.1 指针概述</h2><p>指针变量用于存放一个对象在内存中的地址。通过指针变量可以间接访问变量。</p><h3 id="5-1-1-指针变量的定义"><a href="#5-1-1-指针变量的定义" class="headerlink" title="5.1.1 指针变量的定义"></a>5.1.1 指针变量的定义</h3><p>格式：存储类型 数据类型 *指针变量名;</p><h3 id="5-1-2-指针运算符"><a href="#5-1-2-指针运算符" class="headerlink" title="5.1.2 指针运算符"></a>5.1.2 指针运算符</h3><p>&amp; 取地址运算符<br>* 间接引用运算符<br>在指针变量的定义和指针变量的引用中都有*p。但引用指针时的*与定义指针变量时含义是不同，<br>在指针变量的定义中如<code>int \*p;</code>是指一个指向整型的指针，而在引用时*p是指p所指向的变量。</p><h3 id="5-1-3-指针运算"><a href="#5-1-3-指针运算" class="headerlink" title="5.1.3 指针运算"></a>5.1.3 指针运算</h3><ol><li><p>指针的赋值运算：<br>当向指针变量赋值时，赋的值必须时地址常量或变量，不能是普通整数。<br>指针赋值运算常见额有以下几种形式：把一个变量的地址赋予一个指向相同数据类型的指针；<br>把一个指针的值赋予相同数据类型的另外一个指针；把数组的地址赋予指向相同数据类型的指针。</p></li><li><p>指针的算术运算：<br>指针与整数的加减运算：指指针从当前指向位置向前或向后移动几个数据单元。<br>由于指针可以指向不同数据类型，即数据长度不同的数据，所以这种运算的结果值取决于指针所指向的数据类型。该运算通常用于对数据元素进行操作的场合。<br>两个指针相减运算：指在两个指针指向的变量类型相同时相减的结果为两个指针所指的地址之间相隔的数据元素的个数。</p></li><li><p>指针的关系运算：<br>在两个指向相同类型变量的指针之间可以进行各种关系运算，它实现对两个指针所指变量地址值的比较。</p></li></ol><h3 id="5-1-4-const指针"><a href="#5-1-4-const指针" class="headerlink" title="5.1.4 const指针"></a>5.1.4 const指针</h3><ol><li>指向常量的指针<br>格式：<code>const 数据类型 \*指针变量名;</code><br>说明：在程序中不能通过指针来改变它所指向的数据的值，但是指针本身的值可以改变。</li><li>指针常量<br>格式：<code>数据类型 \*const 指针变量名=初始地址值;</code><br>说明：指针本身的值不可改变，但它所指向的数据的值可以改变。</li><li>指向常量的指针常量<br>格式：<code>const 数据类型 \*const 指针变量名=初始地址值;</code><br>说明：指针本身的值不可改变，它所指向的数据的值也不能通过指针改变。</li></ol><h2 id="5-2-指针与数组"><a href="#5-2-指针与数组" class="headerlink" title="5.2 指针与数组"></a>5.2 指针与数组</h2><ol><li><p>数组元素的访问</p><ul><li>地址法：一个数组名代表它的起始地址。地址法即通过地址访问某一数组元素。<br>如定义<code>int a[5];</code>则对数组的第i+1个元素的访问可以用<code>a[i]</code>或<code>*(a+i)</code>。<br>对于二维数组如定义<code>int b[2][3];</code>则b[0],b[1]分别代表第一行和第二行的首地址。<br>所以要访问数组元素b[i][j]可以用下列几种形式：<br><code>*(*(b+i)+j)、*(b[i]+j)、*(b+3*i+j)</code></li><li>指针法：通过指针访问某一数组元素。<br>如定义一个指向数组元素的指针，<code>int a[5],*p=a;</code>，则对数组的第i+1个元素的访问可以用<code>*(p+i)</code>它等价于a[i]。<br>对于二维数组如定义<code>int b[2][3],*q=b[0];</code><br>则访问数组元素b[i][j]可以用以下几种形式：<br><code>*(*(q+i)+j)、*(q[i]+j)、*(q+i)[j]、*(q+3*i+j)、q[i][j]</code></li></ul></li><li><p>数组指针与指针数组</p><ul><li>数组指针：<br>格式：<code>数据类型 (*指针名) [常量表达式];</code><br>说明：数组指针是一个指向一维数组的指针变量。</li><li>指针数组：<br>格式：<code>数据类型 *指针数组名[常量表达式];</code><br>说明：数组元素尾指针的数组，即数组中的每个元素为指向既定的数据类型的指针。</li></ul></li></ol><h2 id="5-3-指针与函数"><a href="#5-3-指针与函数" class="headerlink" title="5.3 指针与函数"></a>5.3 指针与函数</h2><h3 id="5-3-1-指针作为函数参数"><a href="#5-3-1-指针作为函数参数" class="headerlink" title="5.3.1 指针作为函数参数"></a>5.3.1 指针作为函数参数</h3><p>若指针作为某函数的参数，对该函数的调用即为传地址调用。</p><h3 id="5-3-2-指针型函数"><a href="#5-3-2-指针型函数" class="headerlink" title="5.3.2 指针型函数"></a>5.3.2 指针型函数</h3><p>当一个函数的返回值是指针类型时，这个函数就是指针型函数。它的作用是当需要返回大量数据时可以通过指针型函数完成，<br>当然这需要有效组织数据所占的内存空间。这种情况多用于返回数组、字符串等。<br>定义指针函数的函数头的格式为：<code>数据类型 *函数名 (参数表)</code></p><h3 id="5-3-3-函数指针"><a href="#5-3-3-函数指针" class="headerlink" title="5.3.3 函数指针"></a>5.3.3 函数指针</h3><ol><li><p>函数指针就是指向函数的指针。定义格式：<code>数据类型 (*函数指针名) (参数表)</code></p></li><li><p>函数指针变量在使用前应该先给它赋值,格式为：<code>函数指针名=函数名;</code></p></li><li><p>当函数指针指向某函数以后，可以用下列形式调用函数：<code>(*指针变量)(实参表列)</code></p></li><li><p>函数指针数组<br>定义格式：<code>数据类型 (*函数指针名[常量表达式]) (参数表);</code><br>说明：函数指针数组中的每个元素是一个指向既定类型函数的指针。<br>每个元素所指向的函数具有相同的数据类型和相同的参数类型和参数个数。</p></li></ol><h2 id="5-4-指针与字符串"><a href="#5-4-指针与字符串" class="headerlink" title="5.4 指针与字符串"></a>5.4 指针与字符串</h2><p>可以定义一个字符指针，通过指针的指向来访问所需的字符。<br>常用的字符串处理函数：</p><ul><li>strcat()：字符串拼接函数，将字符串s2连接到s1的后面，并返回s1的地址值</li><li>strcmp():字符串比较函数，比较两个字符串s1和s2的大小（如果由参数n，比较前n个字符的大小）。<br>当字符串s1大于、等于或小于字符串s2时，函数返回值分别是正数、零和负数。</li><li>strcpy()：将s2所指向的字符串复制到s1所指向的字符数组中，然后返回s1的地址值</li><li>strlen()：返回字符串s的长度</li></ul><h2 id="5-5-动态存储分配"><a href="#5-5-动态存储分配" class="headerlink" title="5.5 动态存储分配"></a>5.5 动态存储分配</h2><p>动态内存分配的存储空间在堆中，堆也称为自由存储单元。new运算符与delete运算符一起使用，<br>就可以直接进行动态内存的申请和释放（也称为创建和删除）。</p><h3 id="5-5-1-new运算符"><a href="#5-5-1-new运算符" class="headerlink" title="5.5.1 new运算符"></a>5.5.1 new运算符</h3><p>new运算符用于申请所需的内存单元，返回指定类型的一个指针。</p><ol><li>用new动态分配某种类型的变量<br>格式：<code>指针=new 数据类型;</code><br>说明：指针应预先声明，指针指向的数据类型与new后的数据类型相同。若申请成功，则返回分配单元的首地址给指针；否则（比如没有足够的内存空间），则返回0（一个空指针）。</li><li>用new动态分配数组<br>格式：<code>指针=new 数据类型[常量表达式];</code><br>说明：常量表达式给出数组元素的个数，指针指向分配的内存首地址，指针的类型与new后的数据类型相同。</li></ol><h3 id="5-5-2-delete运算符"><a href="#5-5-2-delete运算符" class="headerlink" title="5.5.2 delete运算符"></a>5.5.2 delete运算符</h3><p>delete运算符用于释放new申请到的内存空间。<br>格式一：<code>delete 指针;</code> 作用：释放非数组内存单元。<br>格式二：<code>delete[常量] 指针;</code> 作用：释放数组内存单元。<br>其中，指针时是指向需要释放的内存单元的指针的名字。并且delete只是删除动态内存单元，并不会将指针本身删除。</p><h2 id="5-6-引用的概念及应用"><a href="#5-6-引用的概念及应用" class="headerlink" title="5.6 引用的概念及应用"></a>5.6 引用的概念及应用</h2><p>引用是个变量的别名，当建立引用时，程序用另一个变量或对象（目标）的名字初始化它。<br>引用通常用来做函数的参数或函数的返回值。<br>声明引用的格式为：<code>类型 &amp;引用名=变量名;</code></p>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 01</title>
    <link href="/blog/20200207/"/>
    <url>/blog/20200207/</url>
    
    <content type="html"><![CDATA[<p>第一章 基本数据类型、运算符与表达式</p><p>第二章 C++程序的流程控制</p><p>第三章 数组</p><p>第四章 C++函数与程序结构</p><a id="more"></a><h1 id="第一章-基本数据类型、运算符与表达式"><a href="#第一章-基本数据类型、运算符与表达式" class="headerlink" title="第一章 基本数据类型、运算符与表达式"></a>第一章 基本数据类型、运算符与表达式</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><h3 id="1-1-1-基本数据类型"><a href="#1-1-1-基本数据类型" class="headerlink" title="1.1.1 基本数据类型"></a>1.1.1 基本数据类型</h3><p>逻辑型：bool<br>字符型：char 1个字节<br>整型：int<br>浮点型：float 4个字节 double 8个字节<br>空类型：void 说明函数没有返回值</p><p>修饰符：<br>signed：有符号<br>unsigned：无符号<br>short：修饰int<br>long：修饰int和double</p><h3 id="1-1-2-复合数据类型"><a href="#1-1-2-复合数据类型" class="headerlink" title="1.1.2 复合数据类型"></a>1.1.2 复合数据类型</h3><ol><li>数组：具有相同数据类型的元素组成的集合</li><li>结构体：由不同的数据据类型构成的混合数据结构，数据成员在内存中占据不同的存储单元</li><li>共同体：与结构体类似，不同在于数据成员共用同一段内存单元</li><li>枚举：将变量的值一一列举出来，每个枚举符都与一个整数相对应 枚举符所赋的值从0开始递增</li><li>指针类型：用于存储零一变量的地址，在内存中占据一个存储单元</li><li>类类型：类是体现面对对象程序设计的最基本特征，也是体现C++与C最大的不同之处。类由数据和方法组成，描述了属于该类型的所有对象的性质</li></ol><h2 id="1-2-变量与常量"><a href="#1-2-变量与常量" class="headerlink" title="1.2 变量与常量"></a>1.2 变量与常量</h2><h3 id="1-2-1-变量：运行期间值可以改变"><a href="#1-2-1-变量：运行期间值可以改变" class="headerlink" title="1.2.1 变量：运行期间值可以改变"></a>1.2.1 变量：运行期间值可以改变</h3><p>三个特征：变量类型、变量名、变量值<br>命名：遵循标识符命名规则。只能由字母、数字和下划线组成，且以字母或下划线开头</p><h3 id="1-2-2-常量：程序执行期间值不变"><a href="#1-2-2-常量：程序执行期间值不变" class="headerlink" title="1.2.2 常量：程序执行期间值不变"></a>1.2.2 常量：程序执行期间值不变</h3><p>主要有：布尔常量、字符常量、字符串常量、整性常量、浮点数常量、枚举常量、符号常量</p><h2 id="1-3-运算符与表达式"><a href="#1-3-运算符与表达式" class="headerlink" title="1.3 运算符与表达式"></a>1.3 运算符与表达式</h2><p>表达式是计算求值的基本单位，有运算符和运算数组成。<br>运算数包括变量、常量和函数等。<br>运算符按其在表达式中与运算对象的关系可分为：单目运算、双目运算、三目运算</p><h2 id="1-4-简单输入和输出"><a href="#1-4-简单输入和输出" class="headerlink" title="1.4 简单输入和输出"></a>1.4 简单输入和输出</h2><p>C++中，I/O使用了流的概念-字符（或字节）流。<br>头文件：iostream.h用于提供基本的输入输出功能，iomanip.h用于提供格式化的功能</p><h3 id="1-4-1-I-O的书写格式（基本数据类型的输入输出）"><a href="#1-4-1-I-O的书写格式（基本数据类型的输入输出）" class="headerlink" title="1.4.1 I/O的书写格式（基本数据类型的输入输出）"></a>1.4.1 I/O的书写格式（基本数据类型的输入输出）</h3><p>头文件iostream,h包括有cin和cout对象，对应于标准输入流和标准输出流。<br>‘&gt;&gt;’表述流的输入，从cin输入流中读取字符；’&lt;&lt;’表示流的输出，可以向cout输出流插入字符</p><h1 id="第二章-C-程序的流程控制"><a href="#第二章-C-程序的流程控制" class="headerlink" title="第二章 C++程序的流程控制"></a>第二章 C++程序的流程控制</h1><ol><li>顺序控制语句：声明语句、表达式语句、输入输出语句等</li><li>选择控制语句：if语句和switch语句</li><li>循环控制语句：while语句、do···while语句、for语句</li><li>跳转语句：break语句、continue语句</li></ol><h1 id="第三章-数组"><a href="#第三章-数组" class="headerlink" title="第三章 数组"></a>第三章 数组</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>数组由一组具有相同数据类型的元素组成的集合。构成数组的这组元素在内存中占用一组连续的存储单元</p><h3 id="3-1-1-一维数组"><a href="#3-1-1-一维数组" class="headerlink" title="3.1.1 一维数组"></a>3.1.1 一维数组</h3><ol><li>定义：类型 数组名[常量表达式];</li><li>初始化：类型 数组名[常量表达式]={值1，值2，···，值n};</li><li>访问数组元素：数组名[下标]</li></ol><h3 id="3-1-2-二维数组"><a href="#3-1-2-二维数组" class="headerlink" title="3.1.2 二维数组"></a>3.1.2 二维数组</h3><ol><li>定义：类型 数组名[常量表达式1][常量表达式2];</li><li>初始化：主要有两种形式：<br>数组按行用花括号分组对二维数组初始化；<br>所有数组按顺序在一个花括号中给出</li><li>访问数组元素：数组名[下标1][下标2]</li></ol><h1 id="第四章-C-函数与程序结构"><a href="#第四章-C-函数与程序结构" class="headerlink" title="第四章 C++函数与程序结构"></a>第四章 C++函数与程序结构</h1><h2 id="4-1-函数的定义与函数原型"><a href="#4-1-函数的定义与函数原型" class="headerlink" title="4.1 函数的定义与函数原型"></a>4.1 函数的定义与函数原型</h2><h3 id="4-1-1-函数的定义"><a href="#4-1-1-函数的定义" class="headerlink" title="4.1.1 函数的定义"></a>4.1.1 函数的定义</h3><p>格式：函数类型 函数名 （形式参数列表）<br>{<br>函数体<br>}</p><h3 id="4-1-2-函数原型"><a href="#4-1-2-函数原型" class="headerlink" title="4.1.2 函数原型"></a>4.1.2 函数原型</h3><p>函数原型告诉编译器函数名、函数类型、函数参数个数及类型。编译器可以对函数调用进行检查。<br>格式：函数类型 函数名（形式参数列表）；</p><h2 id="4-2-函数的调用方法与函数的参数传递规则"><a href="#4-2-函数的调用方法与函数的参数传递规则" class="headerlink" title="4.2 函数的调用方法与函数的参数传递规则"></a>4.2 函数的调用方法与函数的参数传递规则</h2><h3 id="4-2-1-函数的调用方法"><a href="#4-2-1-函数的调用方法" class="headerlink" title="4.2.1 函数的调用方法"></a>4.2.1 函数的调用方法</h3><ol><li>使用函数（即函数调用）主要有三种方式：<br>将函数用作一个独立的表达式语句；<br>用作某条语句的一部分；<br>用作另一个函数的实参。</li><li>格式： 函数名（实际参数列表）</li><li>函数调用的过程：首先传递参数，其次执行函数体，最后返回调用该函数的位置。</li></ol><h3 id="4-2-2-参数传递规则"><a href="#4-2-2-参数传递规则" class="headerlink" title="4.2.2 参数传递规则"></a>4.2.2 参数传递规则</h3><p>在函数调用时，实参要向形参传递信息使形参具有确切的含义（即使形参具有对应的存储空间和初值）。<br>参数传递主要有两种方式：按值传递和引用传递。</p><ol><li>按值传递：按值传递参数时，生成实际参数值的副本并传递给被调用函数的形式参数，形参值的改变不会影响到实参。</li><li>引用传递：引用传递时将形参作为实参的别名，所以通过形参可以直接访问实参数据，也就是说对形参值的改变就是对实参值的改变。<br>引用传递中需在定义形式参数时在形参前加引用符’&amp;’。</li><li>地址传递：地址传递是将实参的地址传递给形参，所以对形参所指地址中的内容进行修改也会是实参值发生改变。<br>按地址传递中需将形式参数的类型定义为指针类型。</li></ol><h2 id="4-3-带有默认参数的函数"><a href="#4-3-带有默认参数的函数" class="headerlink" title="4.3 带有默认参数的函数"></a>4.3 带有默认参数的函数</h2><p>程序员可以指定参数的默认值。当调用程序没有给出实参时，按指定的默认值为形参赋值。<br>函数调用时实参与形参按照从左到右的顺序匹配，当实参全部匹配而形参还有剩余时，则剩下的形参采用默认值。<br>在对默认值进行定义时应该从右向左定义，在一个没有默认值的参数的最左边又出现有默认值的参数时错误的。<br>默认参数应在函数名首次出现时定义。</p><h2 id="4-4-内联函数"><a href="#4-4-内联函数" class="headerlink" title="4.4 内联函数"></a>4.4 内联函数</h2><p>当程序执行到调用普通函数时程序就转去执行该函数，执行完该被调用函数后再返回到调用函数。<br>对于内联函数在编译阶段编译器就把每个出现调用该内联函数的地方都用该函式体中的代码替代。<br>因此内联函数的使用会减少函数调用的开销，但是会增加程序的长度。</p><h2 id="4-5-函数重载"><a href="#4-5-函数重载" class="headerlink" title="4.5 函数重载"></a>4.5 函数重载</h2><p>函数重载是指同一个函数名可以对应多个函数实现。也就是说这些函数具有相同的函数名，完成含义相同的工作。<br>但是他们具有不同的参数（即参数个数或参数类型不同），在函数调用时根据参数的类型、个数决定具体调用哪个函数。<br>函数重载时首先进行参数完全匹配，当无法完全匹配时，按隐式数据类型转换的方向进行匹配，仍无法匹配时，则报错。<br>函数重载解析与函数定义或声明的顺序无关。当多个函数参数个数及类型均相同，只有函数返回值类型不同时则报错。</p><h2 id="4-6-数组参数"><a href="#4-6-数组参数" class="headerlink" title="4.6 数组参数"></a>4.6 数组参数</h2><p>数组作为函数参数时，它传递的时数组中第0个元素的地址（指针）。因此在被调用函数中对新参数组值的改变将被应用到实参数组。<br>数组常数不是参数类型的一部分，函数不知道传递给它的数组的实际长度，当编译器对实参类型进行参数类型检查时并不检查数组的长度，<br>因此在定义形参时可以只写数组名[]，方括号中是否写长度作用相同。</p><h2 id="4-7-变量的作用域与生存期"><a href="#4-7-变量的作用域与生存期" class="headerlink" title="4.7 变量的作用域与生存期"></a>4.7 变量的作用域与生存期</h2><h3 id="4-7-1-局部变量与全局变量"><a href="#4-7-1-局部变量与全局变量" class="headerlink" title="4.7.1 局部变量与全局变量"></a>4.7.1 局部变量与全局变量</h3><ol><li>程序的内存区域：一个程序将操作系统分配给其运行的内存块分为四个区域。<br>代码区，存放程序的代码，即程序中各个函数中的代码块<br>全局数据区，存放程序全局数据和静态数据<br>堆区，存放程序的动态数据<br>栈区，存放程序的局部数据，即各个函数中的数据</li><li>局部变量：在一个函数内部说明的变量是局部变量，旨在该函数范围内有效。</li><li>全局变量：在函数外部定义的变量成为外部变量，外部变量不属于任何同一个函数，<br>其作用域：从外部变量的定义位置开始，到本文结束位置。<br>外部变量可被作用域内的所有函数直接引用，所以外部变量又称全局变量。</li></ol><h3 id="4-7-2-静态变量"><a href="#4-7-2-静态变量" class="headerlink" title="4.7.2 静态变量"></a>4.7.2 静态变量</h3><ol><li><p>静态局部变量<br>定义格式：static 数据类型 内部变量表<br>存储特点：<br>静态局部变量属于静态存储。在程序执行过程中，即使所在函数调用结束也不释放。<br>换句话说，在程序执行期间，静态内部变量始终存在，但其他函数是不能引用它们的。<br>定义但不初始化，则自动赋以’0’（整型和实型）或’\0’（字符型）；<br>且每次调用它们所在的函数时，不在重新赋初值，只是保留上次调用结束时的值。</p></li><li><p>静态全局变量<br>在全局变量前加一个static，使该变量只在这个源文件中可用，称之为全局静态变量。<br>全局静态变量就是静态全局变量。<br>静态全局变量对组成该程序的其他源文件时无效的。</p></li></ol><h3 id="4-7-3-生命期"><a href="#4-7-3-生命期" class="headerlink" title="4.7.3 生命期"></a>4.7.3 生命期</h3><ol><li>静态生命期<br>这种生命期与程序的运行期相同，只要程序一开始运行，这种生命期的变量就存在，<br>在程序结束时，其生命期就结束。</li><li>局部生命期<br>在函数内部声明的变量或者是块中声明的变量具有局部生命期。</li><li>动态生命期<br>这种生命期由程序中特定的函数调用（malloc()和free()）<br>或操作符（new和delete）来创建和释放。</li></ol>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown手册</title>
    <link href="/blog/20200118/"/>
    <url>/blog/20200118/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 .md, .markdown。</p><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。如下：</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落的换行是使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___~~删除线~~</code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong><br><del>删除线</del></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p><pre><code>------------- *************</code></pre><hr><hr><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。<br>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记。<br>有序列表使用数字并加上(.)号来表示，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素  </code></pre><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><pre><code>&gt; 区块引用&gt; 123</code></pre><blockquote><p>区块引用<br>123</p></blockquote><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表，直接在 &gt; 后使用列表，例如：</p><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项</code></pre><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。如：</p><pre><code>* 第一项    &gt; 123    &gt; 456* 第二项</code></pre><ul><li>第一项<blockquote><p>123<br>456</p></blockquote></li><li>第二项</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(`)，<br>例如：`printf()` 函数显示为<code>printf()</code></p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 4 个空格或者一个制表符（Tab 键），还可以用 (```) 包裹一段代码,如：<br>```javascript<br>$(document).ready(function () {<br>alert(‘RUNOOB’);<br>});<br>```</p><pre><code class="javascript">$(document).ready(function () {    alert(&#39;RUNOOB&#39;);});</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[链接名称](链接地址)或者直接使用(链接地址)，例如：<br><a href="www.baidu.com">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![图片描述文字](图片地址)![图片描述文字](图片地址 &quot;可选标题&quot;)</code></pre><pre><code>![avatar](https://regnover.xyz/img/avatar.jpg)![avatar](https://regnover.xyz/img/avatar.jpg &quot;avatar&quot;)</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>对齐方式：<br>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><pre><code>    | 左对齐 | 右对齐 | 居中对齐 |    | :-----| ----: | :----: |    | 单元格 | 单元格 | 单元格 |    | 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 4</title>
    <link href="/blog/20200117/"/>
    <url>/blog/20200117/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p><a id="more"></a><p>示例 1:<br>nums1 = [1, 3]，nums2 = [2]<br>则中位数是 2.0<br>示例 2:<br>nums1 = [1, 2]，nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>