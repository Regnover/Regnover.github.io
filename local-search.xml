<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 05</title>
    <link href="/blog/20200211/"/>
    <url>/blog/20200211/</url>
    
    <content type="html"><![CDATA[<p>第九章 模板<br>第十章 流类库和输入输出</p><a id="more"></a><h1 id="第九章-模板"><a href="#第九章-模板" class="headerlink" title="第九章 模板"></a>第九章 模板</h1><h2 id="9-1-模板的概念"><a href="#9-1-模板的概念" class="headerlink" title="9.1 模板的概念"></a>9.1 模板的概念</h2><p>模板是实现代码复用的一种工具，它可以实现类型参数化，把类型定义为参数，实现代码的真正复用。<br>模板分两类：函数模板和类模板。用一个代码段指定一组函数称为函数模板，或用一个代码段指定一组相关类称为类模版。</p><h2 id="9-2-函数模板的定义与使用"><a href="#9-2-函数模板的定义与使用" class="headerlink" title="9.2 函数模板的定义与使用"></a>9.2 函数模板的定义与使用</h2><h3 id="9-2-1-函数模板的定义"><a href="#9-2-1-函数模板的定义" class="headerlink" title="9.2.1 函数模板的定义"></a>9.2.1 函数模板的定义</h3><p>格式为：</p><pre><code>template &lt;typename(或 class) 数据类型参数标识符&gt;&lt;返回类型&gt;&lt;函数名&gt;(参数表){函数体}</code></pre><h3 id="9-2-2-模板函数"><a href="#9-2-2-模板函数" class="headerlink" title="9.2.2 模板函数"></a>9.2.2 模板函数</h3><p>在使用函数模板时，要将形参“数据类型参数标识符”实例化为确定的数据类型。<br>将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。</p><h3 id="9-2-3-重载模板函数"><a href="#9-2-3-重载模板函数" class="headerlink" title="9.2.3 重载模板函数"></a>9.2.3 重载模板函数</h3><p>函数模板可使用多种方式重载。可以使用其它函数模板，指定不同参数的相同函数名。也可以用非模板函数重载。</p><ol><li>用非模板函数重载函数模板有两种方法：<ul><li>借用函数模板的函数体，只声明非模板函数的原型，它的函数体借用函数模板的函数体。</li><li>重新定义函数体。即重新定义一个完整的非模板函数，它所带的参数可以随意。</li></ul></li><li>在 C++中，函数模板与同名的非模板函数重载时，应遵循下列调用原则：<br>首先寻找一个参数完全匹配的函数，若找到就调用它。<br>若找不到，则寻找一个函数模板，将其实例化生成一个匹配的模板函数，若找到就调用它。<br>若找不到，则从第一步中通过类型转换产生参数匹配，若找到就调用它。否则调用失败。</li></ol><h2 id="9-3-类模板的定义和使用"><a href="#9-3-类模板的定义和使用" class="headerlink" title="9.3    类模板的定义和使用"></a>9.3 类模板的定义和使用</h2><h3 id="9-3-1-类模板的定义"><a href="#9-3-1-类模板的定义" class="headerlink" title="9.3.1 类模板的定义"></a>9.3.1 类模板的定义</h3><p>格式为：</p><pre><code>template&lt;class 数据类型参数标识符&gt; class 类名{//……}；</code></pre><h3 id="9-3-2-模板类"><a href="#9-3-2-模板类" class="headerlink" title="9.3.2 模板类"></a>9.3.2 模板类</h3><p>将类模板的模板参数实例化后生成的具体的类，就是模板类。由类模板生成模板类的一般形式为：<br>类名&lt;模板实参表&gt; 对象名 1，对象名 2，…，对象名 n；</p><h1 id="第十章-流类库和输入输出"><a href="#第十章-流类库和输入输出" class="headerlink" title="第十章 流类库和输入输出"></a>第十章 流类库和输入输出</h1><h2 id="10-1-流的概念及流类库"><a href="#10-1-流的概念及流类库" class="headerlink" title="10.1 流的概念及流类库"></a>10.1 流的概念及流类库</h2><h3 id="10-1-1-流的概念"><a href="#10-1-1-流的概念" class="headerlink" title="10.1.1 流的概念"></a>10.1.1 流的概念</h3><p>C++中的流是指数据从一个对象传递到另一个对象的操作。从流中读取数据称为提取操作，向流内添加数据称为插入操作。<br>流在使用前要建立，使用后要删除。如果数据的传递是在设备之间进行，这种流就称为 I/O 流。<br>C++专门内置了一些供用户使用的类，在这些类中封装了可以实现输入输出操作的函数，这些类统称为 I/O 流类。<br>C++流预定义了 4 个标准流类对象，它们可以直接用来输入输出。这些标准流类对象都包含在头文件 iostream.h 中。<br>istream cin; //与标准输入设备相关联的标准输入流。<br>ostream cout; //与标准输出设备相关联的标准输出流。<br>ostream cerr; //与标准错误输出设备相关联的非缓冲方式的标准输出流。<br>ostream clog; //与标准错误输出设备相关联的缓冲方式的标准输出流。</p><h3 id="10-1-2-流类库"><a href="#10-1-2-流类库" class="headerlink" title="10.1.2    流类库"></a>10.1.2 流类库</h3><p>C++的流类库有两个平行的基类 streambuf 和 ios，其它的流类都是从这两个基类直接或间接派生的。<br>使用这些流类库时，必须包含相应的头文件。</p><h2 id="10-2-输入输出的格式控制"><a href="#10-2-输入输出的格式控制" class="headerlink" title="10.2    输入输出的格式控制"></a>10.2 输入输出的格式控制</h2><p>C++仍可使用 C 中的 printf()和 scanf()进行格式化控制，同时又提供了两种格式化控制的方法，<br>一是使用 ios 类中的有关格式控制的成员函数，二是使用执行格式化输入/输出的格式控制符。</p><h3 id="10-2-1-用-ios-类的成员函数进行格式控制"><a href="#10-2-1-用-ios-类的成员函数进行格式控制" class="headerlink" title="10.2.1    用 ios 类的成员函数进行格式控制"></a>10.2.1 用 ios 类的成员函数进行格式控制</h3><p>使用这种方式进行格式控制主要是通过设置及清除格式状态标志、设置域宽、设置填充字符和设置输出精度的操作来完成的。</p><h3 id="10-2-2-用格式控制符进行格式控制"><a href="#10-2-2-用格式控制符进行格式控制" class="headerlink" title="10.2.2    用格式控制符进行格式控制"></a>10.2.2 用格式控制符进行格式控制</h3><ul><li>预定义的格式控制符</li><li>自定义的格式控制符</li></ul><h2 id="10-3-输入与输出运算符的重载"><a href="#10-3-输入与输出运算符的重载" class="headerlink" title="10.3 输入与输出运算符的重载"></a>10.3 输入与输出运算符的重载</h2><ol><li>定义运算符“&lt;&lt;”重载函数的一般形式为：<pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;stream,类名 对象名){//操作代码return stream;}</code></pre></li><li>定义运算符“&gt;&gt;”重载函数的一般形式为：<pre><code class="istream">{//操作代码return stream;}</code></pre></li></ol><h2 id="10-4-文件操作"><a href="#10-4-文件操作" class="headerlink" title="10.4    文件操作"></a>10.4 文件操作</h2><h3 id="10-4-1-创建文件流"><a href="#10-4-1-创建文件流" class="headerlink" title="10.4.1 创建文件流"></a>10.4.1 创建文件流</h3><p>在 C++中进行文件操作，要包含&lt;fstream.h&gt;。该头文件包括了 ifstream（从文件输入）、ofstream（向文件输出）、<br>fstream（从文件输入输出）流类的定义。它们分别派生自 istream、ostream、iostream。<br>建立文件流就是定义文件流类的对象。如<br>ifstream fin; ofstream fout; fstream fio;<br>建立了流以后，就可以把某一个流与文件建立联系，进行文件的读写操作了。</p><h3 id="10-4-2-文件的打开与关闭"><a href="#10-4-2-文件的打开与关闭" class="headerlink" title="10.4.2 文件的打开与关闭"></a>10.4.2 文件的打开与关闭</h3><p>可以在定义文件流对象的同时完成打开文件的工作，也可在定义文件流对象以后通过open()函数完成。<br>open()函数是上述三个流类的成员函数，定义在 fstream.h 头文件中。<br>函数原型为：<code>void open(const unsigned char *,int mode,int dcces=filebuf::openprot);</code><br>说明：第一个参数用来传递文件名；第二个参数的值决定文件打开的方式，必须从下列值中选取：<br>ios::app //使输出追加到文件尾部，只用于输出<br>ios::ate //查找文件尾<br>ios::in //打开一个文件进行读操作，只用于输入<br>ios::nocreate //文件不存在，导致 open()失败<br>ios::noreplace //若文件存在，则 open()失败<br>ios::out //打开一个文件进行写操作，只用于输出<br>ios::trunc //删除同名文件<br>ios::binary //以二进制方式打开文件，缺省为文本方式以上各值可以组合使用，之间用“|”分开。</p><h3 id="10-4-3-文件的读写"><a href="#10-4-3-文件的读写" class="headerlink" title="10.4.3 文件的读写"></a>10.4.3 文件的读写</h3><ul><li>文件的顺序读写<br>get()函数 ：它从流中每次读出一个字节或一个字符放入引用 ch&amp;中。<br>put()函数：它将一个字节或一个字符写入流中。<br>read()函数：从相应的流读出 num 个字节或字符的数据，把他们放入指针所指向的缓冲区中。<br>buf 是一个指向读入数据存放空间的指针，num 说明要读入数据的字节或字符数。<br>write()函数：从 buf 所指向的缓冲区把 num 个字节的数据写到相应的流中。<br>参数的含义、调用及注意事项与 read()相同。</li><li>文件的随机读写<br>完成定位操作的函数如下：<br>函数 seekg()：用于输入文件，将文件的读指针从 origin 说明的位置移动 offset 个字节；<br>函数 seekp()：用于输出文件，将文件的写指针从 origin 说明的位置移动 offset 个字节。<br>函数 tellg()：用于输入文件，确定文件当前指针的位置。<br>函数 tellp()：用于输出文件，确定文件当前指针的位置。</li></ul>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 04</title>
    <link href="/blog/20200210/"/>
    <url>/blog/20200210/</url>
    
    <content type="html"><![CDATA[<p>第七章 继承性与派生类<br>第八章 多态性与虚函数</p><a id="more"></a><h1 id="第七章-继承性与派生类"><a href="#第七章-继承性与派生类" class="headerlink" title="第七章 继承性与派生类"></a>第七章 继承性与派生类</h1><h2 id="7-1-继承性与派生类的基本概念"><a href="#7-1-继承性与派生类的基本概念" class="headerlink" title="7.1 继承性与派生类的基本概念"></a>7.1 继承性与派生类的基本概念</h2><p>继承是软件复用的一种形式，它是从现有类的基础上建立新类，新类继承了现有类的属性和方法，<br>并且还拥有其特有的属性和方法。继承的过程称为派生，新建的类为派生类（或子类），原有的类称为基类（或父类）。<br>继承可分为：单继承和多重继承。若派生类只有一个基类则称为单继承；若派生类有多个基类则称为多重继承。</p><h2 id="7-2-派生类的声明与访问权限"><a href="#7-2-派生类的声明与访问权限" class="headerlink" title="7.2 派生类的声明与访问权限"></a>7.2 派生类的声明与访问权限</h2><h3 id="7-2-1-派生类的声明"><a href="#7-2-1-派生类的声明" class="headerlink" title="7.2.1    派生类的声明"></a>7.2.1 派生类的声明</h3><p>单继承中派生类的定义格式为：</p><pre><code>class &lt;派生类名&gt;：&lt;派生方式&gt;&lt;基类名&gt;{派生类新定义的成员声明；}；</code></pre><h3 id="7-2-2-派生类的访问权限"><a href="#7-2-2-派生类的访问权限" class="headerlink" title="7.2.2    派生类的访问权限"></a>7.2.2 派生类的访问权限</h3><p>公有继承（public）、私有继承（private）、保护继承（protected）</p><h2 id="7-3-派生类构造函数和析构函数的定义及使用"><a href="#7-3-派生类构造函数和析构函数的定义及使用" class="headerlink" title="7.3    派生类构造函数和析构函数的定义及使用"></a>7.3 派生类构造函数和析构函数的定义及使用</h2><p>在派生过程中，构造函数和析构函数不被继承。在创建一个派生类对象时，分别调用基类和派生类的构造函数，<br>完成各自成员的初始化工作。当撤销一个派生类对象时，分别调用基类和派生类的析构函数完成善后处理工作。</p><ul><li>在 C++中对构造函数与析构函数的调用顺序有如下规定：<br>对于构造函数，先执行基类的，再执行对象成员的，最后执行派生类的。<br>对于析构函数，先执行派生类的，再执行对象成员的，最后执行基类的。</li><li>派生类构造函数定义格式为：<pre><code>&lt;派生类名&gt;::&lt;派生类名&gt;(参数总表):基类名(参数表),对象成员名 1(参数表 1),…,对象成员名 n(参数表 n){//派生类新增成员的初始化语句}</code></pre></li></ul><h2 id="7-4-多重继承的声明、构造函数和析构函数的定义及使用"><a href="#7-4-多重继承的声明、构造函数和析构函数的定义及使用" class="headerlink" title="7.4    多重继承的声明、构造函数和析构函数的定义及使用"></a>7.4 多重继承的声明、构造函数和析构函数的定义及使用</h2><h3 id="7-4-1-多重继承的声明"><a href="#7-4-1-多重继承的声明" class="headerlink" title="7.4.1    多重继承的声明"></a>7.4.1 多重继承的声明</h3><p>多重继承声明的格式为：</p><pre><code>class &lt;派生类名&gt;：&lt;派生方式 1&gt;&lt;基类名 1&gt;,…,&lt;派生方式 n&gt;&lt;基类名 n&gt;{派生类成员声明；};</code></pre><p>说明：这里的派生方式以及访问权限定义与单继承中规则相同。</p><h3 id="7-4-2-多重继承的构造函数与析构函数"><a href="#7-4-2-多重继承的构造函数与析构函数" class="headerlink" title="7.4.2    多重继承的构造函数与析构函数"></a>7.4.2 多重继承的构造函数与析构函数</h3><ul><li>多重继承中对构造函数和析构函数的调用顺序的规定：<br>对于构造函数，先执行基类的，再执行对象成员的，最后执行派生类的。<br>多个基类构造函数的执行次序严格按照声明时从左到右的顺序来执行的，与定义派生类构造函数时指定的初始化表中的次序无关。<br>多个对象成员所在类的构造函数的执行次序按照对象成员定义的顺序来执行。<br>析构函数的调用顺序正好与构造函数的调用顺序相反。</li><li>定义多重继承构造函数的格式为：<pre><code>&lt;派生类名&gt;::&lt;派生类名&gt;(参数总表):基类名 1(参数表 1),…,基类名 n(参数表 n),对象成员名 1(对象成员参数表 1),…,对象成员名 m(对象成员参数表 m){//派生类新增成员的初始化语句}</code></pre>说明：单继承中构造函数定义的说明在多重继承构造函数中均适用。</li></ul><h2 id="7-5-虚基类的作用、定义和使用"><a href="#7-5-虚基类的作用、定义和使用" class="headerlink" title="7.5    虚基类的作用、定义和使用"></a>7.5 虚基类的作用、定义和使用</h2><h3 id="7-5-1-多重继承中的二义性问题"><a href="#7-5-1-多重继承中的二义性问题" class="headerlink" title="7.5.1    多重继承中的二义性问题"></a>7.5.1 多重继承中的二义性问题</h3><p>问题的产生：</p><ol><li>当派生类继承的多个基类中存在同名成员时，派生类中就会出现来自不同基类的同名成员，<br>就出现了标识符不唯一或二义性的情况，这在程序中是不允许的。</li><li>当一个类从多个基类派生而来，这多个基类又有共同的基类，则在派生类中访问这个共同基类中的成员时会产生二义性。<br>解决办法：<br>对于第一种情况：</li><li>使用作用域运算符“::”</li><li>使用同名覆盖的原则</li><li>使用虚函数(在下一章中介绍)<br>对于第二种情况：<br>使用虚基类</li></ol><h3 id="7-5-2-虚基类"><a href="#7-5-2-虚基类" class="headerlink" title="7.5.2 虚基类"></a>7.5.2 虚基类</h3><p><img src="/img/C++7_5_2.png" srcset="/img/loading.gif" alt="C++7_5_2"><br>如上图所示，对于非虚基类的情况，derived 有两个基类 base1 和 base2，这两个基类又有共同基类 base，<br>derived 类中就有基类 base 的两个不同的拷贝。在 derived 要访问 base 类中的成员时，就会产生二义性问题。<br>虚基类就是为了解决这个问题而引入的。<br>对于虚基类的情况，derived 中的公共基类 base 就只有一个拷贝而不会出现二义性问题。</p><h3 id="7-5-3-虚基类的定义"><a href="#7-5-3-虚基类的定义" class="headerlink" title="7.5.3 虚基类的定义"></a>7.5.3 虚基类的定义</h3><p>虚基类的声明是在派生类的声明过程中进行的，格式为：<br>class&lt;派生类名&gt;:virtual &lt;派生方式&gt;&lt;基类名&gt;<br>说明：</p><ol><li>虚基类关键字的作用范围和派生方式与一般派生类的一样，只对紧跟其后的基类起作用。</li><li>声明了虚基类以后，虚基类的成员在进一步派生过程中和派生类一起维护同一个内存拷贝。</li></ol><h3 id="7-5-4-虚基类的构造函数和初始化"><a href="#7-5-4-虚基类的构造函数和初始化" class="headerlink" title="7.5.4 虚基类的构造函数和初始化"></a>7.5.4 虚基类的构造函数和初始化</h3><p>虚基类的初始化与一般的多继承的初始化在语法上是一样的，但构造函数的执行顺序不同：</p><ol><li>虚基类的构造函数在非虚基类的构造函数之前执行。</li><li>若同一层次中包含多个虚基类，这些虚基类的构造函数按它们说明的先后次序执行。</li><li>若虚基类由非虚基类派生而来，则仍然先执行基类的构造函数，再执行派生类的构造函数。</li></ol><h1 id="第八章-多态性与虚函数"><a href="#第八章-多态性与虚函数" class="headerlink" title="第八章 多态性与虚函数"></a>第八章 多态性与虚函数</h1><h2 id="8-1-多态性的概念"><a href="#8-1-多态性的概念" class="headerlink" title="8.1    多态性的概念"></a>8.1 多态性的概念</h2><p>在面向对象的概念中，多态性是指不同对象接收到相同消息时，根据对象类的不同产生不同的动作。<br>由静态联编支持的多态性称为编译时的多态性或静态多态性，也就是说，确定同名操作的具体操作对象的过程是<br>在编译过程中完成的。C++用函数重载和运算符重载来实现编译时的多态性。<br>由动态联编支持的多态性称为运行时的多态性活动或动态多态性，<br>也就是说，确定同名操作的具体操作对象的过程是在运行过程中完成的。C++用继承和虚函数来实现运行时的多态性。</p><h2 id="8-2-函数和运算符的重载"><a href="#8-2-函数和运算符的重载" class="headerlink" title="8.2 函数和运算符的重载"></a>8.2 函数和运算符的重载</h2><h3 id="8-2-1-函数重载"><a href="#8-2-1-函数重载" class="headerlink" title="8.2.1 函数重载"></a>8.2.1 函数重载</h3><p>面向对象程序设计中，函数的重载表现为两种情况：第一种是参数个数或类型有所差别的重载，第二种是函数的参数完全相同但属于不同的类。</p><h3 id="8-2-2-运算符重载"><a href="#8-2-2-运算符重载" class="headerlink" title="8.2.2 运算符重载"></a>8.2.2 运算符重载</h3><p>C++预定义的运算符只是对基本数据类型进行操作，而对于自定义的数据类型比如类，却没有类似的操作。<br>为了实现对自定义类型的操作，就必须自己编写程序来说明某个运算符作用在这些数据类型上时，<br>应该完成怎样的操作，这就要引入运算符重载的概念。<br>运算符的重载形式有两种，一种是重载为类的成员函数，一种是重载为类的友元函数。</p><ol><li><p>将运算符重载为它将要操作的类的成员函数，称为成员运算符函数。<br>实际使用时，总是通过该类的某个对象访问重载的运算符。<br>成员运算符函数的定义：<br>在类内声明的一般形式为：&lt;返回类型&gt; operator&lt;运算符&gt;(参数表)；<br>在类外定义的一般形式为：</p><pre><code>&lt;返回类型&gt; &lt;类名∷&gt; operator&lt;运算符&gt;(参数表){函数体}</code></pre><p>其中，operator 是定义运算符重载函数的关键字；运算符是要重载的运算符的名称；参数表给出重载运算符所需要的参数和类型。</p></li><li><p>将重载的运算符函数定义为类的友元函数，称为友元运算符函数。<br>友元运算符函数不是类的成员，它在类内声明原型，在类外定义函数本身。由于它不是类的成员函数，<br>不属于任何一个类对象，所以没有 this 指针，因此，重载双目运算符时要有两个参数，重载单目运算符时只要一个参数就可以了。<br>友员运算符函数的定义：<br>在类内声明的一般形式为：<br>friend&lt;返回类型&gt; operator&lt;运算符&gt;(参数表)；<br>在类外定义的一般形式为：</p><pre><code>&lt;返回类型&gt; operator&lt;运算符&gt;(参数表){函数体}</code></pre><p>其中，friend 是声明友元函数的关键字， operator 是定义运算符重载函数的关键字；<br>运算符是要重载的运算符的名称；参数表给出重载运算符所需要的参数和类型。</p></li><li><p>几种典型运算符的重载</p><ul><li>加法运算符“+”的重载</li><li>“++”和“–”的重载</li><li>赋值运算符“=”的重载</li><li>函数调用运算符“（）”的重载</li><li>下标运算符“[ ]”的重载</li></ul></li></ol><h2 id="8-3-虚函数和抽象类"><a href="#8-3-虚函数和抽象类" class="headerlink" title="8.3 虚函数和抽象类"></a>8.3 虚函数和抽象类</h2><p>虚函数是重载的另一种形式，实现的是动态的重载，即函数调用与函数体之间的联系是在运行时才建立，也就是动态联编。</p><h3 id="8-3-1-虚函数的定义和使用"><a href="#8-3-1-虚函数的定义和使用" class="headerlink" title="8.3.1 虚函数的定义和使用"></a>8.3.1 虚函数的定义和使用</h3><p>虚函数的定义是在基类中进行的，即把基类中需要定义为虚函数的成员函数声明为virtual。<br>当基类中的某个成员函数被声明为虚函数后，它就可以在派生类中被重新定义。<br>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和类型、参数的顺序都必须与基类中的原型完全一致。<br>虚函数定义的一般形式为：</p><pre><code>virtual&lt;函数类型&gt;&lt;函数名&gt;(参数表){函数体}</code></pre><h3 id="8-3-2-纯虚函数和抽象类"><a href="#8-3-2-纯虚函数和抽象类" class="headerlink" title="8.3.2 纯虚函数和抽象类"></a>8.3.2 纯虚函数和抽象类</h3><p>抽象类是一种特殊的类，它为一族类提供统一的操作界面，建立抽象类就是为了通过它多态地使用其中的成员函数。抽象类是带有纯虚函数的类。<br>一个抽象类至少带有一个纯虚函数。纯虚函数是在一个基类中说明的虚函数，它在该基类中没有具体的操作内容，<br>要求各派生类在重新定义时根据自己的需要定义实际的操作内容。<br>纯虚函数的一般定义形式为：virtual&lt;函数类型&gt;&lt;函数名&gt;(参数表)=0；<br>纯虚函数与普通虚函数的定义的不同在于书写形式上加了“=0”，说明在基类中不用定义该函数的函数体，它的函数体由派生类定义。<br>如果一个类中至少有一个纯虚函数，这个类就成为抽象类。它的主要作用是为一个族类提供统一的公共接口，以有效地发挥多态的特性。</p>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 03</title>
    <link href="/blog/20200209/"/>
    <url>/blog/20200209/</url>
    
    <content type="html"><![CDATA[<p>第六章 类和对象的创建</p><a id="more"></a><h1 id="第六章-类和对象的创建"><a href="#第六章-类和对象的创建" class="headerlink" title="第六章 类和对象的创建"></a>第六章 类和对象的创建</h1><h2 id="6-1-类和对象"><a href="#6-1-类和对象" class="headerlink" title="6.1 类和对象"></a>6.1 类和对象</h2><h3 id="6-1-1-类的定义"><a href="#6-1-1-类的定义" class="headerlink" title="6.1.1 类的定义"></a>6.1.1 类的定义</h3><p>类实质上是用户自定义的一种特殊的数据类型，它不仅包含相关的数据，还包含能对这<br>些数据进行处理的函数，同时，这些数据具有隐蔽性和封装性。<br>类中包含的数据和函数统称为成员，数据称为数据成员，函数称为成员函数，它们都有自己的访问权限。<br>类定义一般分为两部分，即说明部分和实现部分。说明部分用于说明该类中的成员，实现部分用于对成员函数进行定义。</p><ul><li><p>类定义格式</p><pre><code>class 类名{  private:  私有数据成员和成员函数  protected:  保护数据成员和成员函数  public:  公有数据成员和成员函数};各成员函数的实现</code></pre></li><li><p>类成员的访问控制<br>类成员有三种不访问权限：私有（private）、保护（protected）、公有（public）。</p></li><li><p>类的数据成员与成员函数<br>类定义中声明数据成员的数据类型和名称，不能在类内说明数据成员的同时为其赋初值，<br>只有在类的对象定义以后才能给数据成员赋初值。对于成员函数可以在类内定义，<br>也可以在类内给出函数原型，然后在类外对成员函数进行定义。<br>成员函数在类内说明原型，在类外给出定义时其定义格式如下：</p><pre><code>返回类型 类名::函数名 参数表{ //函数体}</code></pre></li></ul><h3 id="6-1-2-对象的定义和使用"><a href="#6-1-2-对象的定义和使用" class="headerlink" title="6.1.2 对象的定义和使用"></a>6.1.2 对象的定义和使用</h3><p>对象的定义：类定义只是定义了一种新的数据类型，只有定义了类的实例即类的对象以后系统才会为该对象分配存储空间。<br>对象定义可以在类定义的同时直接完成，即在类定义的最后“}”后直接跟对象名列表；<br>也可以在类定义后要使用该对象时定义。<br>格式：类名对象名（参数列表）；<br>说明：可以同时定义多个对象，之间用逗号隔开。<br>对象成员的引用<br>格式：<br>对象名.数据成员；<br>对象名.成员函数（实参表）；</p><h2 id="6-2-构造函数和析构函数"><a href="#6-2-构造函数和析构函数" class="headerlink" title="6.2 构造函数和析构函数"></a>6.2 构造函数和析构函数</h2><h3 id="6-2-1-构造函数"><a href="#6-2-1-构造函数" class="headerlink" title="6.2.1 构造函数"></a>6.2.1 构造函数</h3><p>构造函数是一种特殊的成员函数，被声明为公有成员，其作用是为类的对象分配内存空间，进行初始化。<br>关于构造函数有以下几点说明：</p><ol><li>构造函数的名字必须与类的名字相同。</li><li>构造函数没有返回值，不能定义返回类型，包括 void 型在内。</li><li>对象定义时，编译系统会自动地调用构造函数完成对象内存空间的分配和初始化工作。</li><li>构造函数是类的成员函数，具有一般成员函数的所有性质，可访问类的所有成员，<br>可以是内联函数，可带有参数表，可带有默认的形参值，还可重载。</li><li>如果没有定义构造函数，编译系统就自动生成一个缺省的构造函数，这个缺省的构造函数不带任何参数，<br>仅给对象开辟存储空间，不完成对数据成员赋初值。此时数据成员的值是随机的。<br>系统自动生成的构造函数的形式为：<pre><code> 类名∷类名() { }</code></pre></li></ol><h3 id="6-2-2-析构函数"><a href="#6-2-2-析构函数" class="headerlink" title="6.2.2 析构函数"></a>6.2.2 析构函数</h3><p>析构函数也是一种特殊的成员函数，也被声明为公有成员，其作用是释放分配给对象的内存空间，并做一些善后工作。<br>关于析构函数有以下几点说明：</p><ol><li>析构函数的名字必须是 ~类名。</li><li>析构函数没有参数、没有返回值、不能重载。</li><li>当对象撤销时，系统会自动调用析构函数完成内存空间的释放和善后工作。</li><li>如果没有定义析构函数，系统会自动生成一个缺省的空析构函数。完成善后工作，其形式为：<pre><code>类名::~类名(){}</code></pre>对于构造函数和析构函数常见用法是在构造函数中用 new 动态申请空间，<br>在析构函数中用 delete 释放内存空间。</li></ol><h3 id="6-2-3-拷贝构造函数"><a href="#6-2-3-拷贝构造函数" class="headerlink" title="6.2.3 拷贝构造函数"></a>6.2.3 拷贝构造函数</h3><p>拷贝构造函数是一个特殊的构造函数，其作用是用一个已经存在的对象初始化本类的新对象。<br>每个类都有一个拷贝构造函数，它可以是根据用户的需要自定义，也可以由系统自动生成。<br>拷贝构造函数名与类名相同，但参数是本类对象的引用。拷贝构造函数没有返回值。<br>定义拷贝构造函数的格式为：</p><pre><code>类名(类名&amp;对象名){//函数体}</code></pre><p>其中，对象名是用来初始化另一个对象的对象的引用。<br>构造函数只在对象被创建时自动调用，而拷贝构造函数在下列三种情况下会被自动调用：</p><ol><li>用一个对象去初始化本类的另一个对象时。</li><li>函数的形参是类的对象，在进行形参和实参的结合时。</li><li>函数的返回值是类的对象，函数执行完返回时。</li></ol><h3 id="6-2-4-对象成员"><a href="#6-2-4-对象成员" class="headerlink" title="6.2.4 对象成员"></a>6.2.4 对象成员</h3><ul><li><p>定义对象成员<br>当用一个类的对象作为另一个类的成员时，该成员称为对象成员。声明对象成员的一般格式为：</p><pre><code>class 类名{类名 1    对象成员名 1；//需要此类在前面已经定义或声明。．．．}；</code></pre></li><li><p>对象成员的初始化<br>在类中有对象成员时，创建本类的对象则本类的构造函数要调用其对象成员所在类的构造函数，<br>并采用成员初始化列表对对象成员进行初始化。这种类的构造函数的定义格式为：</p><pre><code>类名∷类名(参数总表)：对象成员 1(形参表)，．．．，对象成员ｎ(形参表){//构造函数体}</code></pre></li></ul><h2 id="6-3-对象数组与对象指针"><a href="#6-3-对象数组与对象指针" class="headerlink" title="6.3 对象数组与对象指针"></a>6.3 对象数组与对象指针</h2><h3 id="6-3-1-对象数组"><a href="#6-3-1-对象数组" class="headerlink" title="6.3.1 对象数组"></a>6.3.1 对象数组</h3><p>对象数组是指数组中的每个元素都是一个类的对象。当然这些对象属于同一个类。</p><ul><li>定义一维对象数组的一般格式为：<br>类名 数组名[常量表达式]；</li><li>对象数组的引用<br>由于对象数组的元素是对象，只能访问其公有成员。<br>引用格式为： 数组名[下标]．公有成员</li></ul><h3 id="6-3-2-对象指针"><a href="#6-3-2-对象指针" class="headerlink" title="6.3.2 对象指针"></a>6.3.2 对象指针</h3><p>对象指针就是对象在内存中的首地址。指向类类型的指针变量用于存放对象指针。<br>其定义格式为：&lt;类名&gt; * &lt;指针变量名&gt;;</p><h2 id="6-4-静态成员"><a href="#6-4-静态成员" class="headerlink" title="6.4 静态成员"></a>6.4 静态成员</h2><p>静态成员是指类中用关键字static说明的那些成员。静态成员仍然服从访问控制。</p><h3 id="6-4-1-静态数据成员"><a href="#6-4-1-静态数据成员" class="headerlink" title="6.4.1 静态数据成员"></a>6.4.1 静态数据成员</h3><p>静态数据成员是指类中用关键字static说明的那些数据成员。<br>静态数据成员属于类而不属于某个对象。它实现同类对象之间的数据共享。</p><ul><li>在类中声明静态数据成员时，必须加 static 说明。</li><li>对静态数据成员初始化只能在类外进行，一般在在类声明与 main()之间的位置。<br>格式为：数据类型 类名∷静态数据成员名=值；</li><li>对静态数据成员的引用可以有两种形式：<br>类名∷静态数据成员 对象名．静态数据成员</li></ul><h3 id="6-4-2-静态成员函数"><a href="#6-4-2-静态成员函数" class="headerlink" title="6.4.2 静态成员函数"></a>6.4.2 静态成员函数</h3><p>静态成员函数是指类中用关键字static说明的那些成员函数。可以用静态成员函数在未建立任何对象之前去处理静态数据成员。<br>静态成员函数只能直接引用该类的静态数据成员和静态成员函数，不能直接引用非静态数据成员。<br>调用静态的两种形式：类名∷静态函数名(); 或 对象名．静态函数名();</p><h2 id="6-5-友元"><a href="#6-5-友元" class="headerlink" title="6.5 友元"></a>6.5 友元</h2><p>C++引入了友元实现了在类的外部访问类的私有成员的功能。这样，即不放弃私有数据的安全性，又可在类的外部访问类的私有成员。<br>但一定程度上说友元破坏了类的封装性，在使用友元时一定要慎重。友元关系是单向的，也是不能传递的。</p><h3 id="6-5-1-友元函数"><a href="#6-5-1-友元函数" class="headerlink" title="6.5.1 友元函数"></a>6.5.1 友元函数</h3><p>一个普通函数作为某个类的友元时即为友元函数。在该函数中可以访问其由 friend 声明语句所在的类的对象的私有成员和公有成员。<br>在类中作如下声明，则说明该函数不是本类的成员函数，而是友元函数。<br>friend 函数类型 友元函数名(参数表);<br>友元函数的定义可以在类内也可以在类外，在类外定义时不需要加类名和普通函数定义没有区别。<br>通常友元函数的定义在类外进行。友元函数不是类的成员，因而不能直接引用对象成员的名字，<br>也不能通过 this 指针引用对象的成员，必须通过作为入口参数传递进来的对象名或对象指针来引用该对象的成员。<br>为此，友元函数一般都带有一个该类的入口参数。</p><h3 id="6-5-2-友元成员函数"><a href="#6-5-2-友元成员函数" class="headerlink" title="6.5.2    友元成员函数"></a>6.5.2 友元成员函数</h3><p>某个类的成员函数作为另一个类的友元即为友元成员函数。通过友元成员函数，可以访问由 friend 声明语句所在的类的对象的私有成员和公有成员。<br>当一个类 A 的成员函数作为另一个类 B 的友元函数时，在类 B 中的声明格式为：<br>friend 函数类型 成员函数所在类类名::函数名（参数表）；</p><h3 id="6-5-3-友类"><a href="#6-5-3-友类" class="headerlink" title="6.5.3    友类"></a>6.5.3 友类</h3><p>当一个类作为另一个类的友元时即为友类。若类 A 是类 B 的友类，则类 A 中的所有成员函数都是类 B 的友元成员函数，<br>所以可以通过对象名访问 B 的私有成员和公有成员。当类 A 为类B 的友类时，在类 B 中的声明格式为：<br>firiend class &lt;友元类名&gt;; 或 friend &lt;友元类名&gt;;</p>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 02</title>
    <link href="/blog/20200208/"/>
    <url>/blog/20200208/</url>
    
    <content type="html"><![CDATA[<p>第五章 指针、引用和动态空间管理</p><a id="more"></a><h1 id="第五章-指针、引用和动态空间管理"><a href="#第五章-指针、引用和动态空间管理" class="headerlink" title="第五章 指针、引用和动态空间管理"></a>第五章 指针、引用和动态空间管理</h1><h2 id="5-1-指针概述"><a href="#5-1-指针概述" class="headerlink" title="5.1 指针概述"></a>5.1 指针概述</h2><p>指针变量用于存放一个对象在内存中的地址。通过指针变量可以间接访问变量。</p><h3 id="5-1-1-指针变量的定义"><a href="#5-1-1-指针变量的定义" class="headerlink" title="5.1.1 指针变量的定义"></a>5.1.1 指针变量的定义</h3><p>格式：存储类型 数据类型 *指针变量名;</p><h3 id="5-1-2-指针运算符"><a href="#5-1-2-指针运算符" class="headerlink" title="5.1.2 指针运算符"></a>5.1.2 指针运算符</h3><p>&amp; 取地址运算符<br>* 间接引用运算符<br>在指针变量的定义和指针变量的引用中都有*p。但引用指针时的*与定义指针变量时含义是不同，<br>在指针变量的定义中如<code>int \*p;</code>是指一个指向整型的指针，而在引用时*p是指p所指向的变量。</p><h3 id="5-1-3-指针运算"><a href="#5-1-3-指针运算" class="headerlink" title="5.1.3 指针运算"></a>5.1.3 指针运算</h3><ol><li><p>指针的赋值运算：<br>当向指针变量赋值时，赋的值必须时地址常量或变量，不能是普通整数。<br>指针赋值运算常见额有以下几种形式：把一个变量的地址赋予一个指向相同数据类型的指针；<br>把一个指针的值赋予相同数据类型的另外一个指针；把数组的地址赋予指向相同数据类型的指针。</p></li><li><p>指针的算术运算：<br>指针与整数的加减运算：指指针从当前指向位置向前或向后移动几个数据单元。<br>由于指针可以指向不同数据类型，即数据长度不同的数据，所以这种运算的结果值取决于指针所指向的数据类型。该运算通常用于对数据元素进行操作的场合。<br>两个指针相减运算：指在两个指针指向的变量类型相同时相减的结果为两个指针所指的地址之间相隔的数据元素的个数。</p></li><li><p>指针的关系运算：<br>在两个指向相同类型变量的指针之间可以进行各种关系运算，它实现对两个指针所指变量地址值的比较。</p></li></ol><h3 id="5-1-4-const指针"><a href="#5-1-4-const指针" class="headerlink" title="5.1.4 const指针"></a>5.1.4 const指针</h3><ol><li>指向常量的指针<br>格式：<code>const 数据类型 \*指针变量名;</code><br>说明：在程序中不能通过指针来改变它所指向的数据的值，但是指针本身的值可以改变。</li><li>指针常量<br>格式：<code>数据类型 \*const 指针变量名=初始地址值;</code><br>说明：指针本身的值不可改变，但它所指向的数据的值可以改变。</li><li>指向常量的指针常量<br>格式：<code>const 数据类型 \*const 指针变量名=初始地址值;</code><br>说明：指针本身的值不可改变，它所指向的数据的值也不能通过指针改变。</li></ol><h2 id="5-2-指针与数组"><a href="#5-2-指针与数组" class="headerlink" title="5.2 指针与数组"></a>5.2 指针与数组</h2><ol><li><p>数组元素的访问</p><ul><li>地址法：一个数组名代表它的起始地址。地址法即通过地址访问某一数组元素。<br>如定义<code>int a[5];</code>则对数组的第i+1个元素的访问可以用<code>a[i]</code>或<code>*(a+i)</code>。<br>对于二维数组如定义<code>int b[2][3];</code>则b[0],b[1]分别代表第一行和第二行的首地址。<br>所以要访问数组元素b[i][j]可以用下列几种形式：<br><code>*(*(b+i)+j)、*(b[i]+j)、*(b+3*i+j)</code></li><li>指针法：通过指针访问某一数组元素。<br>如定义一个指向数组元素的指针，<code>int a[5],*p=a;</code>，则对数组的第i+1个元素的访问可以用<code>*(p+i)</code>它等价于a[i]。<br>对于二维数组如定义<code>int b[2][3],*q=b[0];</code><br>则访问数组元素b[i][j]可以用以下几种形式：<br><code>*(*(q+i)+j)、*(q[i]+j)、*(q+i)[j]、*(q+3*i+j)、q[i][j]</code></li></ul></li><li><p>数组指针与指针数组</p><ul><li>数组指针：<br>格式：<code>数据类型 (*指针名) [常量表达式];</code><br>说明：数组指针是一个指向一维数组的指针变量。</li><li>指针数组：<br>格式：<code>数据类型 *指针数组名[常量表达式];</code><br>说明：数组元素尾指针的数组，即数组中的每个元素为指向既定的数据类型的指针。</li></ul></li></ol><h2 id="5-3-指针与函数"><a href="#5-3-指针与函数" class="headerlink" title="5.3 指针与函数"></a>5.3 指针与函数</h2><h3 id="5-3-1-指针作为函数参数"><a href="#5-3-1-指针作为函数参数" class="headerlink" title="5.3.1 指针作为函数参数"></a>5.3.1 指针作为函数参数</h3><p>若指针作为某函数的参数，对该函数的调用即为传地址调用。</p><h3 id="5-3-2-指针型函数"><a href="#5-3-2-指针型函数" class="headerlink" title="5.3.2 指针型函数"></a>5.3.2 指针型函数</h3><p>当一个函数的返回值是指针类型时，这个函数就是指针型函数。它的作用是当需要返回大量数据时可以通过指针型函数完成，<br>当然这需要有效组织数据所占的内存空间。这种情况多用于返回数组、字符串等。<br>定义指针函数的函数头的格式为：<code>数据类型 *函数名 (参数表)</code></p><h3 id="5-3-3-函数指针"><a href="#5-3-3-函数指针" class="headerlink" title="5.3.3 函数指针"></a>5.3.3 函数指针</h3><ol><li><p>函数指针就是指向函数的指针。定义格式：<code>数据类型 (*函数指针名) (参数表)</code></p></li><li><p>函数指针变量在使用前应该先给它赋值,格式为：<code>函数指针名=函数名;</code></p></li><li><p>当函数指针指向某函数以后，可以用下列形式调用函数：<code>(*指针变量)(实参表列)</code></p></li><li><p>函数指针数组<br>定义格式：<code>数据类型 (*函数指针名[常量表达式]) (参数表);</code><br>说明：函数指针数组中的每个元素是一个指向既定类型函数的指针。<br>每个元素所指向的函数具有相同的数据类型和相同的参数类型和参数个数。</p></li></ol><h2 id="5-4-指针与字符串"><a href="#5-4-指针与字符串" class="headerlink" title="5.4 指针与字符串"></a>5.4 指针与字符串</h2><p>可以定义一个字符指针，通过指针的指向来访问所需的字符。<br>常用的字符串处理函数：</p><ul><li>strcat()：字符串拼接函数，将字符串s2连接到s1的后面，并返回s1的地址值</li><li>strcmp():字符串比较函数，比较两个字符串s1和s2的大小（如果由参数n，比较前n个字符的大小）。<br>当字符串s1大于、等于或小于字符串s2时，函数返回值分别是正数、零和负数。</li><li>strcpy()：将s2所指向的字符串复制到s1所指向的字符数组中，然后返回s1的地址值</li><li>strlen()：返回字符串s的长度</li></ul><h2 id="5-5-动态存储分配"><a href="#5-5-动态存储分配" class="headerlink" title="5.5 动态存储分配"></a>5.5 动态存储分配</h2><p>动态内存分配的存储空间在堆中，堆也称为自由存储单元。new运算符与delete运算符一起使用，<br>就可以直接进行动态内存的申请和释放（也称为创建和删除）。</p><h3 id="5-5-1-new运算符"><a href="#5-5-1-new运算符" class="headerlink" title="5.5.1 new运算符"></a>5.5.1 new运算符</h3><p>new运算符用于申请所需的内存单元，返回指定类型的一个指针。</p><ol><li>用new动态分配某种类型的变量<br>格式：<code>指针=new 数据类型;</code><br>说明：指针应预先声明，指针指向的数据类型与new后的数据类型相同。若申请成功，则返回分配单元的首地址给指针；否则（比如没有足够的内存空间），则返回0（一个空指针）。</li><li>用new动态分配数组<br>格式：<code>指针=new 数据类型[常量表达式];</code><br>说明：常量表达式给出数组元素的个数，指针指向分配的内存首地址，指针的类型与new后的数据类型相同。</li></ol><h3 id="5-5-2-delete运算符"><a href="#5-5-2-delete运算符" class="headerlink" title="5.5.2 delete运算符"></a>5.5.2 delete运算符</h3><p>delete运算符用于释放new申请到的内存空间。<br>格式一：<code>delete 指针;</code> 作用：释放非数组内存单元。<br>格式二：<code>delete[常量] 指针;</code> 作用：释放数组内存单元。<br>其中，指针时是指向需要释放的内存单元的指针的名字。并且delete只是删除动态内存单元，并不会将指针本身删除。</p><h2 id="5-6-引用的概念及应用"><a href="#5-6-引用的概念及应用" class="headerlink" title="5.6 引用的概念及应用"></a>5.6 引用的概念及应用</h2><p>引用是个变量的别名，当建立引用时，程序用另一个变量或对象（目标）的名字初始化它。<br>引用通常用来做函数的参数或函数的返回值。<br>声明引用的格式为：<code>类型 &amp;引用名=变量名;</code></p>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 01</title>
    <link href="/blog/20200207/"/>
    <url>/blog/20200207/</url>
    
    <content type="html"><![CDATA[<p>第一章 基本数据类型、运算符与表达式</p><p>第二章 C++程序的流程控制</p><p>第三章 数组</p><p>第四章 C++函数与程序结构</p><a id="more"></a><h1 id="第一章-基本数据类型、运算符与表达式"><a href="#第一章-基本数据类型、运算符与表达式" class="headerlink" title="第一章 基本数据类型、运算符与表达式"></a>第一章 基本数据类型、运算符与表达式</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><h3 id="1-1-1-基本数据类型"><a href="#1-1-1-基本数据类型" class="headerlink" title="1.1.1 基本数据类型"></a>1.1.1 基本数据类型</h3><p>逻辑型：bool<br>字符型：char 1个字节<br>整型：int<br>浮点型：float 4个字节 double 8个字节<br>空类型：void 说明函数没有返回值</p><p>修饰符：<br>signed：有符号<br>unsigned：无符号<br>short：修饰int<br>long：修饰int和double</p><h3 id="1-1-2-复合数据类型"><a href="#1-1-2-复合数据类型" class="headerlink" title="1.1.2 复合数据类型"></a>1.1.2 复合数据类型</h3><ol><li>数组：具有相同数据类型的元素组成的集合</li><li>结构体：由不同的数据据类型构成的混合数据结构，数据成员在内存中占据不同的存储单元</li><li>共同体：与结构体类似，不同在于数据成员共用同一段内存单元</li><li>枚举：将变量的值一一列举出来，每个枚举符都与一个整数相对应 枚举符所赋的值从0开始递增</li><li>指针类型：用于存储零一变量的地址，在内存中占据一个存储单元</li><li>类类型：类是体现面对对象程序设计的最基本特征，也是体现C++与C最大的不同之处。类由数据和方法组成，描述了属于该类型的所有对象的性质</li></ol><h2 id="1-2-变量与常量"><a href="#1-2-变量与常量" class="headerlink" title="1.2 变量与常量"></a>1.2 变量与常量</h2><h3 id="1-2-1-变量：运行期间值可以改变"><a href="#1-2-1-变量：运行期间值可以改变" class="headerlink" title="1.2.1 变量：运行期间值可以改变"></a>1.2.1 变量：运行期间值可以改变</h3><p>三个特征：变量类型、变量名、变量值<br>命名：遵循标识符命名规则。只能由字母、数字和下划线组成，且以字母或下划线开头</p><h3 id="1-2-2-常量：程序执行期间值不变"><a href="#1-2-2-常量：程序执行期间值不变" class="headerlink" title="1.2.2 常量：程序执行期间值不变"></a>1.2.2 常量：程序执行期间值不变</h3><p>主要有：布尔常量、字符常量、字符串常量、整性常量、浮点数常量、枚举常量、符号常量</p><h2 id="1-3-运算符与表达式"><a href="#1-3-运算符与表达式" class="headerlink" title="1.3 运算符与表达式"></a>1.3 运算符与表达式</h2><p>表达式是计算求值的基本单位，有运算符和运算数组成。<br>运算数包括变量、常量和函数等。<br>运算符按其在表达式中与运算对象的关系可分为：单目运算、双目运算、三目运算</p><h2 id="1-4-简单输入和输出"><a href="#1-4-简单输入和输出" class="headerlink" title="1.4 简单输入和输出"></a>1.4 简单输入和输出</h2><p>C++中，I/O使用了流的概念-字符（或字节）流。<br>头文件：iostream.h用于提供基本的输入输出功能，iomanip.h用于提供格式化的功能</p><h3 id="1-4-1-I-O的书写格式（基本数据类型的输入输出）"><a href="#1-4-1-I-O的书写格式（基本数据类型的输入输出）" class="headerlink" title="1.4.1 I/O的书写格式（基本数据类型的输入输出）"></a>1.4.1 I/O的书写格式（基本数据类型的输入输出）</h3><p>头文件iostream,h包括有cin和cout对象，对应于标准输入流和标准输出流。<br>‘&gt;&gt;’表述流的输入，从cin输入流中读取字符；’&lt;&lt;’表示流的输出，可以向cout输出流插入字符</p><h1 id="第二章-C-程序的流程控制"><a href="#第二章-C-程序的流程控制" class="headerlink" title="第二章 C++程序的流程控制"></a>第二章 C++程序的流程控制</h1><ol><li>顺序控制语句：声明语句、表达式语句、输入输出语句等</li><li>选择控制语句：if语句和switch语句</li><li>循环控制语句：while语句、do···while语句、for语句</li><li>跳转语句：break语句、continue语句</li></ol><h1 id="第三章-数组"><a href="#第三章-数组" class="headerlink" title="第三章 数组"></a>第三章 数组</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>数组由一组具有相同数据类型的元素组成的集合。构成数组的这组元素在内存中占用一组连续的存储单元</p><h3 id="3-1-1-一维数组"><a href="#3-1-1-一维数组" class="headerlink" title="3.1.1 一维数组"></a>3.1.1 一维数组</h3><ol><li>定义：类型 数组名[常量表达式];</li><li>初始化：类型 数组名[常量表达式]={值1，值2，···，值n};</li><li>访问数组元素：数组名[下标]</li></ol><h3 id="3-1-2-二维数组"><a href="#3-1-2-二维数组" class="headerlink" title="3.1.2 二维数组"></a>3.1.2 二维数组</h3><ol><li>定义：类型 数组名[常量表达式1][常量表达式2];</li><li>初始化：主要有两种形式：<br>数组按行用花括号分组对二维数组初始化；<br>所有数组按顺序在一个花括号中给出</li><li>访问数组元素：数组名[下标1][下标2]</li></ol><h1 id="第四章-C-函数与程序结构"><a href="#第四章-C-函数与程序结构" class="headerlink" title="第四章 C++函数与程序结构"></a>第四章 C++函数与程序结构</h1><h2 id="4-1-函数的定义与函数原型"><a href="#4-1-函数的定义与函数原型" class="headerlink" title="4.1 函数的定义与函数原型"></a>4.1 函数的定义与函数原型</h2><h3 id="4-1-1-函数的定义"><a href="#4-1-1-函数的定义" class="headerlink" title="4.1.1 函数的定义"></a>4.1.1 函数的定义</h3><p>格式：函数类型 函数名 （形式参数列表）<br>{<br>函数体<br>}</p><h3 id="4-1-2-函数原型"><a href="#4-1-2-函数原型" class="headerlink" title="4.1.2 函数原型"></a>4.1.2 函数原型</h3><p>函数原型告诉编译器函数名、函数类型、函数参数个数及类型。编译器可以对函数调用进行检查。<br>格式：函数类型 函数名（形式参数列表）；</p><h2 id="4-2-函数的调用方法与函数的参数传递规则"><a href="#4-2-函数的调用方法与函数的参数传递规则" class="headerlink" title="4.2 函数的调用方法与函数的参数传递规则"></a>4.2 函数的调用方法与函数的参数传递规则</h2><h3 id="4-2-1-函数的调用方法"><a href="#4-2-1-函数的调用方法" class="headerlink" title="4.2.1 函数的调用方法"></a>4.2.1 函数的调用方法</h3><ol><li>使用函数（即函数调用）主要有三种方式：<br>将函数用作一个独立的表达式语句；<br>用作某条语句的一部分；<br>用作另一个函数的实参。</li><li>格式： 函数名（实际参数列表）</li><li>函数调用的过程：首先传递参数，其次执行函数体，最后返回调用该函数的位置。</li></ol><h3 id="4-2-2-参数传递规则"><a href="#4-2-2-参数传递规则" class="headerlink" title="4.2.2 参数传递规则"></a>4.2.2 参数传递规则</h3><p>在函数调用时，实参要向形参传递信息使形参具有确切的含义（即使形参具有对应的存储空间和初值）。<br>参数传递主要有两种方式：按值传递和引用传递。</p><ol><li>按值传递：按值传递参数时，生成实际参数值的副本并传递给被调用函数的形式参数，形参值的改变不会影响到实参。</li><li>引用传递：引用传递时将形参作为实参的别名，所以通过形参可以直接访问实参数据，也就是说对形参值的改变就是对实参值的改变。<br>引用传递中需在定义形式参数时在形参前加引用符’&amp;’。</li><li>地址传递：地址传递是将实参的地址传递给形参，所以对形参所指地址中的内容进行修改也会是实参值发生改变。<br>按地址传递中需将形式参数的类型定义为指针类型。</li></ol><h2 id="4-3-带有默认参数的函数"><a href="#4-3-带有默认参数的函数" class="headerlink" title="4.3 带有默认参数的函数"></a>4.3 带有默认参数的函数</h2><p>程序员可以指定参数的默认值。当调用程序没有给出实参时，按指定的默认值为形参赋值。<br>函数调用时实参与形参按照从左到右的顺序匹配，当实参全部匹配而形参还有剩余时，则剩下的形参采用默认值。<br>在对默认值进行定义时应该从右向左定义，在一个没有默认值的参数的最左边又出现有默认值的参数时错误的。<br>默认参数应在函数名首次出现时定义。</p><h2 id="4-4-内联函数"><a href="#4-4-内联函数" class="headerlink" title="4.4 内联函数"></a>4.4 内联函数</h2><p>当程序执行到调用普通函数时程序就转去执行该函数，执行完该被调用函数后再返回到调用函数。<br>对于内联函数在编译阶段编译器就把每个出现调用该内联函数的地方都用该函式体中的代码替代。<br>因此内联函数的使用会减少函数调用的开销，但是会增加程序的长度。</p><h2 id="4-5-函数重载"><a href="#4-5-函数重载" class="headerlink" title="4.5 函数重载"></a>4.5 函数重载</h2><p>函数重载是指同一个函数名可以对应多个函数实现。也就是说这些函数具有相同的函数名，完成含义相同的工作。<br>但是他们具有不同的参数（即参数个数或参数类型不同），在函数调用时根据参数的类型、个数决定具体调用哪个函数。<br>函数重载时首先进行参数完全匹配，当无法完全匹配时，按隐式数据类型转换的方向进行匹配，仍无法匹配时，则报错。<br>函数重载解析与函数定义或声明的顺序无关。当多个函数参数个数及类型均相同，只有函数返回值类型不同时则报错。</p><h2 id="4-6-数组参数"><a href="#4-6-数组参数" class="headerlink" title="4.6 数组参数"></a>4.6 数组参数</h2><p>数组作为函数参数时，它传递的时数组中第0个元素的地址（指针）。因此在被调用函数中对新参数组值的改变将被应用到实参数组。<br>数组常数不是参数类型的一部分，函数不知道传递给它的数组的实际长度，当编译器对实参类型进行参数类型检查时并不检查数组的长度，<br>因此在定义形参时可以只写数组名[]，方括号中是否写长度作用相同。</p><h2 id="4-7-变量的作用域与生存期"><a href="#4-7-变量的作用域与生存期" class="headerlink" title="4.7 变量的作用域与生存期"></a>4.7 变量的作用域与生存期</h2><h3 id="4-7-1-局部变量与全局变量"><a href="#4-7-1-局部变量与全局变量" class="headerlink" title="4.7.1 局部变量与全局变量"></a>4.7.1 局部变量与全局变量</h3><ol><li>程序的内存区域：一个程序将操作系统分配给其运行的内存块分为四个区域。<br>代码区，存放程序的代码，即程序中各个函数中的代码块<br>全局数据区，存放程序全局数据和静态数据<br>堆区，存放程序的动态数据<br>栈区，存放程序的局部数据，即各个函数中的数据</li><li>局部变量：在一个函数内部说明的变量是局部变量，旨在该函数范围内有效。</li><li>全局变量：在函数外部定义的变量成为外部变量，外部变量不属于任何同一个函数，<br>其作用域：从外部变量的定义位置开始，到本文结束位置。<br>外部变量可被作用域内的所有函数直接引用，所以外部变量又称全局变量。</li></ol><h3 id="4-7-2-静态变量"><a href="#4-7-2-静态变量" class="headerlink" title="4.7.2 静态变量"></a>4.7.2 静态变量</h3><ol><li><p>静态局部变量<br>定义格式：static 数据类型 内部变量表<br>存储特点：<br>静态局部变量属于静态存储。在程序执行过程中，即使所在函数调用结束也不释放。<br>换句话说，在程序执行期间，静态内部变量始终存在，但其他函数是不能引用它们的。<br>定义但不初始化，则自动赋以’0’（整型和实型）或’\0’（字符型）；<br>且每次调用它们所在的函数时，不在重新赋初值，只是保留上次调用结束时的值。</p></li><li><p>静态全局变量<br>在全局变量前加一个static，使该变量只在这个源文件中可用，称之为全局静态变量。<br>全局静态变量就是静态全局变量。<br>静态全局变量对组成该程序的其他源文件时无效的。</p></li></ol><h3 id="4-7-3-生命期"><a href="#4-7-3-生命期" class="headerlink" title="4.7.3 生命期"></a>4.7.3 生命期</h3><ol><li>静态生命期<br>这种生命期与程序的运行期相同，只要程序一开始运行，这种生命期的变量就存在，<br>在程序结束时，其生命期就结束。</li><li>局部生命期<br>在函数内部声明的变量或者是块中声明的变量具有局部生命期。</li><li>动态生命期<br>这种生命期由程序中特定的函数调用（malloc()和free()）<br>或操作符（new和delete）来创建和释放。</li></ol>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown手册</title>
    <link href="/blog/20200118/"/>
    <url>/blog/20200118/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 .md, .markdown。</p><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。如下：</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落的换行是使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___~~删除线~~</code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong><br><del>删除线</del></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p><pre><code>------------- *************</code></pre><hr><hr><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。<br>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记。<br>有序列表使用数字并加上(.)号来表示，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素  </code></pre><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><pre><code>&gt; 区块引用&gt; 123</code></pre><blockquote><p>区块引用<br>123</p></blockquote><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表，直接在 &gt; 后使用列表，例如：</p><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项</code></pre><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。如：</p><pre><code>* 第一项    &gt; 123    &gt; 456* 第二项</code></pre><ul><li>第一项<blockquote><p>123<br>456</p></blockquote></li><li>第二项</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(`)，<br>例如：`printf()` 函数显示为<code>printf()</code></p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 4 个空格或者一个制表符（Tab 键），还可以用 (```) 包裹一段代码,如：<br>```javascript<br>$(document).ready(function () {<br>alert(‘RUNOOB’);<br>});<br>```</p><pre><code class="javascript">$(document).ready(function () {    alert(&#39;RUNOOB&#39;);});</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[链接名称](链接地址)或者直接使用(链接地址)，例如：<br><a href="www.baidu.com">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![图片描述文字](图片地址)![图片描述文字](图片地址 &quot;可选标题&quot;)</code></pre><pre><code>![avatar](https://regnover.xyz/img/avatar.jpg)![avatar](https://regnover.xyz/img/avatar.jpg &quot;avatar&quot;)</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>对齐方式：<br>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><pre><code>    | 左对齐 | 右对齐 | 居中对齐 |    | :-----| ----: | :----: |    | 单元格 | 单元格 | 单元格 |    | 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 4</title>
    <link href="/blog/20200117/"/>
    <url>/blog/20200117/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p><a id="more"></a><p>示例 1:<br>nums1 = [1, 3]，nums2 = [2]<br>则中位数是 2.0<br>示例 2:<br>nums1 = [1, 2]，nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>